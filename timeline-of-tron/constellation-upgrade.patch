From 77c95bb1bdbe001694a90b3e8d8b91acb2dbd64b Mon Sep 17 00:00:00 2001
From: Mike <njrun1804@gmail.com>
Date: Mon, 9 Feb 2026 03:44:06 +0000
Subject: [PATCH 1/2] =?UTF-8?q?Constellation:=20add=20graph=20analytics=20?=
 =?UTF-8?q?engine=20=E2=80=94=20PageRank,=20community=20detection,=20relat?=
 =?UTF-8?q?ionship=20decay,=20network=20intelligence?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

New graph-analytics.js module (944 lines) with pure-JS implementations of:
- PageRank (iterative, damped)
- Betweenness centrality (Brandes' algorithm)
- Clustering coefficient per node
- Community detection (greedy modularity optimization)
- Relationship strength with temporal decay (4-year half-life)
- Network health metrics (density, centralization, churn, etc.)
- Composite "Social Gravity" scoring with percentile ranking
- Temporal evolution with Shannon entropy diversity index

Enhanced constellation.js with:
- Analytics-driven node sizing (social gravity + PageRank boost)
- Gold stroke + glow animations on top-percentile nodes
- Community-colored halo rings behind high-rank nodes
- Tooltips show PageRank %, bridge score, percentile
- Edge panels show relationship strength, decay class, recency
- Sidebar: score donut, Social DNA radar chart, activity sparkline
- Network Health Dashboard (8 ring-indicator cards)
- Advanced Metrics Grid (community count, top PageRank, bridges, cliques)
- Community Cards with auto-naming and member stats
- Diversity Over Time dual-axis chart (Shannon entropy + network age)

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>
---
 timeline-of-tron/constellation.html    |  18 +-
 timeline-of-tron/css/constellation.css | 510 +++++++++++++
 timeline-of-tron/js/constellation.js   | 821 ++++++++++++++++++++-
 timeline-of-tron/js/graph-analytics.js | 944 +++++++++++++++++++++++++
 4 files changed, 2287 insertions(+), 6 deletions(-)
 create mode 100644 timeline-of-tron/js/graph-analytics.js

diff --git a/timeline-of-tron/constellation.html b/timeline-of-tron/constellation.html
index 1bb2d42..e5ee996 100644
--- a/timeline-of-tron/constellation.html
+++ b/timeline-of-tron/constellation.html
@@ -54,7 +54,23 @@
         <div class="network-legend" id="networkLegend"></div>
     </section>
 
-    <!-- Network Insights -->
+    <!-- Advanced Analytics: Network Health + Community Detection + Deep Metrics -->
+    <section class="advanced-metrics" id="advancedAnalytics">
+        <h2 class="metrics-section-title">Network Intelligence</h2>
+        <p class="metrics-section-subtitle">Graph theory meets personal history â€” PageRank, community detection, and relationship decay analysis</p>
+        <div id="networkHealthMount" class="network-health"></div>
+        <div id="metricsGridMount" class="metrics-grid"></div>
+        <div id="communitiesMount" class="communities-section"></div>
+    </section>
+
+    <!-- Temporal Diversity Chart -->
+    <section class="temporal-diversity" id="temporalDiversity">
+        <h3>Network Diversity Over Time</h3>
+        <p class="network-subtitle">Shannon entropy of relationship categories â€” how varied the circle was each year</p>
+        <canvas id="diversityChart"></canvas>
+    </section>
+
+    <!-- Network Insights (enhanced) -->
     <section class="network-insights" id="networkInsights"></section>
 
     <div id="lj-footer-mount"></div>
diff --git a/timeline-of-tron/css/constellation.css b/timeline-of-tron/css/constellation.css
index a6a7f8d..64cbbe1 100644
--- a/timeline-of-tron/css/constellation.css
+++ b/timeline-of-tron/css/constellation.css
@@ -1063,3 +1063,513 @@
     .featured-card { min-width: 100px; }
     .featured-row { gap: 8px; }
 }
+
+/* â”€â”€â”€ Advanced Node Effects â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
+
+@keyframes nodePulse {
+    0%, 100% { filter: drop-shadow(0 0 2px currentColor); opacity: 1; }
+    50% { filter: drop-shadow(0 0 8px currentColor); opacity: 0.9; }
+}
+
+@keyframes nodeGlow {
+    0%, 100% { filter: drop-shadow(0 0 4px var(--glow-color, #4a90d9)) drop-shadow(0 0 12px var(--glow-color, #4a90d9)); }
+    50% { filter: drop-shadow(0 0 8px var(--glow-color, #4a90d9)) drop-shadow(0 0 20px var(--glow-color, #4a90d9)); }
+}
+
+.node-important {
+    animation: nodePulse 4s ease-in-out infinite;
+}
+
+.node-hub {
+    animation: nodeGlow 3s ease-in-out infinite;
+}
+
+/* â”€â”€â”€ Social DNA Radar Chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
+
+.social-dna-section {
+    margin-top: 20px;
+    padding: 16px 0;
+    border-top: 1px solid rgba(30, 58, 95, 0.4);
+}
+
+.social-dna-title {
+    font-family: var(--font-sans);
+    font-size: 10px;
+    text-transform: uppercase;
+    letter-spacing: 1px;
+    color: var(--lj-text-secondary);
+    margin-bottom: 12px;
+}
+
+.social-dna-canvas {
+    display: block;
+    margin: 0 auto;
+    max-width: 240px;
+}
+
+.social-dna-labels {
+    display: flex;
+    flex-wrap: wrap;
+    gap: 8px;
+    justify-content: center;
+    margin-top: 10px;
+}
+
+.dna-label {
+    font-family: var(--font-mono);
+    font-size: 10px;
+    color: var(--lj-text-secondary);
+    display: flex;
+    align-items: center;
+    gap: 4px;
+}
+
+.dna-value {
+    color: var(--room-accent);
+    font-weight: 600;
+}
+
+/* â”€â”€â”€ Activity Sparkline â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
+
+.sparkline-section {
+    margin-top: 14px;
+    padding: 10px 0;
+}
+
+.sparkline-label {
+    font-family: var(--font-sans);
+    font-size: 10px;
+    text-transform: uppercase;
+    letter-spacing: 1px;
+    color: var(--lj-text-secondary);
+    margin-bottom: 8px;
+}
+
+.sparkline-container {
+    position: relative;
+    height: 48px;
+    background: rgba(30, 58, 95, 0.15);
+    border-radius: 3px;
+    overflow: hidden;
+}
+
+.sparkline-canvas {
+    display: block;
+    width: 100%;
+    height: 100%;
+}
+
+.sparkline-range {
+    display: flex;
+    justify-content: space-between;
+    font-family: var(--font-mono);
+    font-size: 9px;
+    color: var(--lj-text-secondary);
+    margin-top: 4px;
+    opacity: 0.6;
+}
+
+/* â”€â”€â”€ Advanced Metrics Cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
+
+.advanced-metrics {
+    margin-top: var(--space-lg);
+    padding-top: var(--space-lg);
+    border-top: 1px solid var(--lj-border);
+}
+
+.metrics-section-title {
+    font-family: var(--font-mono);
+    font-size: 1.1rem;
+    color: var(--room-text);
+    text-align: center;
+    margin-bottom: 8px;
+}
+
+.metrics-section-subtitle {
+    font-family: var(--font-sans);
+    font-size: 13px;
+    color: var(--lj-text-secondary);
+    text-align: center;
+    margin-bottom: var(--space-md);
+}
+
+.metrics-grid {
+    display: grid;
+    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
+    gap: 12px;
+    margin-bottom: var(--space-lg);
+}
+
+.metric-card {
+    background: var(--room-panel);
+    border: 1px solid var(--lj-border);
+    border-radius: 4px;
+    padding: 16px;
+    position: relative;
+    overflow: hidden;
+    transition: border-color 0.3s;
+}
+
+.metric-card:hover {
+    border-color: var(--room-accent);
+}
+
+.metric-card-icon {
+    font-size: 20px;
+    margin-bottom: 8px;
+    opacity: 0.8;
+}
+
+.metric-card-value {
+    font-family: var(--font-mono);
+    font-size: 1.6rem;
+    color: var(--room-accent);
+    font-weight: 700;
+    line-height: 1.2;
+}
+
+.metric-card-label {
+    font-family: var(--font-sans);
+    font-size: 12px;
+    color: var(--lj-text-secondary);
+    margin-top: 4px;
+}
+
+.metric-card-detail {
+    font-family: var(--font-sans);
+    font-size: 11px;
+    color: var(--lj-text-secondary);
+    margin-top: 8px;
+    line-height: 1.4;
+    opacity: 0.8;
+}
+
+.metric-card-bar {
+    position: absolute;
+    bottom: 0;
+    left: 0;
+    height: 3px;
+    background: var(--room-accent);
+    opacity: 0.5;
+    transition: width 0.6s ease;
+}
+
+/* â”€â”€â”€ Community Clusters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
+
+.communities-section {
+    margin-top: var(--space-lg);
+}
+
+.communities-grid {
+    display: grid;
+    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
+    gap: 12px;
+}
+
+.community-card {
+    background: var(--room-panel);
+    border: 1px solid var(--lj-border);
+    border-left: 3px solid var(--community-color, var(--room-accent));
+    border-radius: 0 4px 4px 0;
+    padding: 14px 16px;
+}
+
+.community-card-header {
+    display: flex;
+    align-items: center;
+    gap: 8px;
+    margin-bottom: 8px;
+}
+
+.community-dot {
+    width: 10px;
+    height: 10px;
+    border-radius: 50%;
+    flex-shrink: 0;
+}
+
+.community-name {
+    font-family: var(--font-mono);
+    font-size: 13px;
+    color: var(--room-text);
+}
+
+.community-count {
+    font-family: var(--font-mono);
+    font-size: 11px;
+    color: var(--lj-text-secondary);
+    margin-left: auto;
+}
+
+.community-members {
+    display: flex;
+    flex-wrap: wrap;
+    gap: 4px;
+    margin-top: 6px;
+}
+
+.community-member {
+    font-family: var(--font-sans);
+    font-size: 11px;
+    padding: 2px 8px;
+    background: rgba(74, 144, 217, 0.1);
+    border: 1px solid rgba(74, 144, 217, 0.15);
+    border-radius: 10px;
+    color: var(--room-accent);
+    cursor: pointer;
+    transition: background 0.2s;
+}
+
+.community-member:hover {
+    background: rgba(74, 144, 217, 0.25);
+}
+
+.community-stats {
+    display: flex;
+    gap: 12px;
+    margin-top: 8px;
+    font-family: var(--font-mono);
+    font-size: 10px;
+    color: var(--lj-text-secondary);
+}
+
+/* â”€â”€â”€ Relationship Strength â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
+
+.strength-indicator {
+    display: flex;
+    align-items: center;
+    gap: 6px;
+    margin-top: 6px;
+}
+
+.strength-bar-track {
+    flex: 1;
+    height: 4px;
+    background: rgba(30, 58, 95, 0.3);
+    border-radius: 2px;
+    overflow: hidden;
+}
+
+.strength-bar-fill {
+    height: 100%;
+    border-radius: 2px;
+    transition: width 0.4s ease;
+}
+
+.strength-label {
+    font-family: var(--font-mono);
+    font-size: 10px;
+    color: var(--lj-text-secondary);
+    min-width: 50px;
+    text-align: right;
+}
+
+.strength-strong .strength-bar-fill { background: #4a90d9; }
+.strength-moderate .strength-bar-fill { background: #c9a84c; }
+.strength-weak .strength-bar-fill { background: #7a8fa6; }
+.strength-dormant .strength-bar-fill { background: #b45050; opacity: 0.5; }
+
+/* â”€â”€â”€ Percentile Badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
+
+.percentile-badge {
+    display: inline-flex;
+    align-items: center;
+    gap: 4px;
+    padding: 3px 10px;
+    border-radius: 12px;
+    font-family: var(--font-mono);
+    font-size: 11px;
+    margin-top: 6px;
+}
+
+.percentile-badge.top-10 {
+    background: rgba(201, 168, 76, 0.15);
+    border: 1px solid rgba(201, 168, 76, 0.3);
+    color: #c9a84c;
+}
+
+.percentile-badge.top-25 {
+    background: rgba(74, 144, 217, 0.12);
+    border: 1px solid rgba(74, 144, 217, 0.25);
+    color: #4a90d9;
+}
+
+.percentile-badge.top-50 {
+    background: rgba(107, 74, 139, 0.12);
+    border: 1px solid rgba(107, 74, 139, 0.25);
+    color: #9b7abf;
+}
+
+.percentile-badge.bottom-half {
+    background: rgba(122, 143, 166, 0.1);
+    border: 1px solid rgba(122, 143, 166, 0.2);
+    color: #7a8fa6;
+}
+
+/* â”€â”€â”€ Enhanced Edge Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
+
+.edge-strength-section {
+    margin-top: 12px;
+    padding: 10px 0;
+    border-top: 1px solid rgba(30, 58, 95, 0.3);
+}
+
+.edge-strength-label {
+    font-family: var(--font-sans);
+    font-size: 10px;
+    text-transform: uppercase;
+    letter-spacing: 1px;
+    color: var(--lj-text-secondary);
+    margin-bottom: 6px;
+}
+
+.edge-strength-grid {
+    display: grid;
+    grid-template-columns: 1fr 1fr;
+    gap: 6px;
+}
+
+.edge-stat {
+    font-family: var(--font-mono);
+    font-size: 11px;
+    padding: 4px 6px;
+    background: rgba(74, 144, 217, 0.06);
+    border-radius: 3px;
+}
+
+.edge-stat-label {
+    font-family: var(--font-sans);
+    font-size: 9px;
+    color: var(--lj-text-secondary);
+    display: block;
+}
+
+.edge-stat-value {
+    color: var(--room-accent);
+    font-weight: 600;
+}
+
+/* â”€â”€â”€ Network Health Dashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
+
+.network-health {
+    display: grid;
+    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
+    gap: 10px;
+    margin-top: var(--space-md);
+    margin-bottom: var(--space-lg);
+}
+
+.health-card {
+    text-align: center;
+    padding: 12px 8px;
+    background: var(--room-panel);
+    border: 1px solid var(--lj-border);
+    border-radius: 4px;
+    position: relative;
+}
+
+.health-card-ring {
+    width: 56px;
+    height: 56px;
+    margin: 0 auto 8px;
+    position: relative;
+}
+
+.health-card-ring svg {
+    width: 100%;
+    height: 100%;
+    transform: rotate(-90deg);
+}
+
+.health-card-ring-value {
+    position: absolute;
+    top: 50%;
+    left: 50%;
+    transform: translate(-50%, -50%);
+    font-family: var(--font-mono);
+    font-size: 14px;
+    color: var(--room-accent);
+    font-weight: 700;
+}
+
+.health-card-label {
+    font-family: var(--font-sans);
+    font-size: 11px;
+    color: var(--lj-text-secondary);
+}
+
+.health-card-sublabel {
+    font-family: var(--font-mono);
+    font-size: 10px;
+    color: var(--room-accent);
+    opacity: 0.7;
+    margin-top: 2px;
+}
+
+/* â”€â”€â”€ Temporal Diversity Chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
+
+.temporal-diversity {
+    max-width: 960px;
+    margin: var(--space-lg) auto;
+    padding: 0 24px;
+}
+
+.temporal-diversity h3 {
+    font-family: var(--font-mono);
+    font-size: 1.1rem;
+    color: var(--room-text);
+    text-align: center;
+    margin-bottom: 4px;
+}
+
+.temporal-diversity .network-subtitle {
+    margin-bottom: var(--space-md);
+}
+
+.temporal-diversity canvas {
+    max-width: 100%;
+}
+
+/* â”€â”€â”€ Sidebar Score Donut â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
+
+.score-donut-section {
+    display: flex;
+    align-items: center;
+    gap: 14px;
+    margin-top: 14px;
+    padding: 12px;
+    background: rgba(30, 58, 95, 0.15);
+    border-radius: 4px;
+}
+
+.score-donut-svg {
+    width: 64px;
+    height: 64px;
+    flex-shrink: 0;
+    transform: rotate(-90deg);
+}
+
+.score-donut-text {
+    flex: 1;
+}
+
+.score-donut-value {
+    font-family: var(--font-mono);
+    font-size: 22px;
+    color: var(--room-accent);
+    font-weight: 700;
+}
+
+.score-donut-label {
+    font-family: var(--font-sans);
+    font-size: 11px;
+    color: var(--lj-text-secondary);
+    margin-top: 2px;
+}
+
+.score-donut-rank {
+    font-family: var(--font-mono);
+    font-size: 10px;
+    color: #c9a84c;
+    margin-top: 4px;
+}
diff --git a/timeline-of-tron/js/constellation.js b/timeline-of-tron/js/constellation.js
index 73c4fd1..6a27ad9 100644
--- a/timeline-of-tron/js/constellation.js
+++ b/timeline-of-tron/js/constellation.js
@@ -1,9 +1,20 @@
 // js/constellation.js â€” Room 2: The Constellation (People + Relationships)
-// D3 force graph of 164 people as stars on a dark background
+// D3 force graph with advanced graph analytics: PageRank, community detection,
+// betweenness centrality, relationship decay, and temporal evolution
 
 import { loadMultiple } from './data-loader.js';
 import { initWormholes } from './wormholes.js';
 import { plantClue } from './room0.js';
+import {
+    computePageRank,
+    computeBetweenness,
+    computeClusteringCoeff,
+    detectCommunities,
+    computeRelationshipStrength,
+    computeNetworkHealth,
+    computePersonScores,
+    computeTemporalEvolution
+} from './graph-analytics.js';
 
 const ERA_COLORS = {
     early: '#4a90d9',    // 2004-2008: blue
@@ -133,6 +144,17 @@ let ecdPlayerNetworkData = { nodes: [], links: [] };
 let songsByPerson = {};
 let lifeChaptersData = [];
 
+// â”€â”€â”€ Advanced Analytics Results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+let analyticsPageRank = new Map();
+let analyticsBetweenness = new Map();
+let analyticsClustering = new Map();
+let analyticsCommunities = { communities: new Map(), modularity: 0, communityColors: new Map() };
+let analyticsRelStrength = new Map();
+let analyticsNetworkHealth = {};
+let analyticsPersonScores = new Map();
+let analyticsTemporalEvolution = [];
+let analyticsReady = false;
+
 // Build a nameâ†’ECD player lookup (case-insensitive matching for awards)
 function buildEcdPlayerMap(playersArray) {
     const map = {};
@@ -250,6 +272,71 @@ export async function initConstellation() {
 
     if (!constellation || !constellation.nodes) return;
 
+    // â”€â”€â”€ Run Advanced Graph Analytics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+    try {
+        const arcArr = Array.isArray(data.person_arc) ? data.person_arc : [];
+        // Normalize arc data to have .name field
+        const normalizedArc = arcArr.map(a => ({ ...a, name: a.person || a.name }));
+
+        // Build co-occurrence count map: "nameA|nameB" â†’ count
+        const coOccMap = new Map();
+        (coOccurrencesData || []).forEach(co => {
+            if (!co.person_a || !co.person_b) return;
+            const [a, b] = co.person_a < co.person_b
+                ? [co.person_a, co.person_b] : [co.person_b, co.person_a];
+            const key = `${a}|${b}`;
+            coOccMap.set(key, (coOccMap.get(key) || 0) + (co.co_occurrence_count || 1));
+        });
+
+        // Minimal node list for analytics (just need .name)
+        const analyticsNodes = [
+            { name: 'John Tronolone' },
+            ...constellation.nodes.map(n => ({ name: n.name }))
+        ];
+        // Minimal link list (string source/target)
+        const analyticsLinks = [
+            ...(constellation.links || []).map(l => ({
+                source: l.source, target: l.target, weight: l.weight || 1
+            })),
+            ...(coOccurrencesData || []).filter(co => co.person_a && co.person_b).map(co => ({
+                source: co.person_a, target: co.person_b,
+                weight: Math.min(co.co_occurrence_count || 1, 3)
+            })),
+            ...(ecdPlayerNetworkData.links || []).map(l => ({
+                source: l.source, target: l.target, weight: l.weight || 1
+            }))
+        ];
+
+        analyticsPageRank = computePageRank(analyticsNodes, analyticsLinks);
+        analyticsBetweenness = computeBetweenness(analyticsNodes, analyticsLinks);
+        analyticsClustering = computeClusteringCoeff(analyticsNodes, analyticsLinks);
+        analyticsCommunities = detectCommunities(analyticsNodes, analyticsLinks);
+        analyticsRelStrength = computeRelationshipStrength(
+            analyticsNodes, analyticsLinks, coOccMap, normalizedArc
+        );
+        analyticsNetworkHealth = computeNetworkHealth(
+            analyticsNodes, analyticsLinks, normalizedArc
+        );
+        analyticsPersonScores = computePersonScores(
+            analyticsNodes, analyticsLinks,
+            analyticsPageRank, analyticsBetweenness, analyticsClustering,
+            normalizedArc
+        );
+        analyticsTemporalEvolution = computeTemporalEvolution(
+            analyticsNodes, normalizedArc
+        );
+        analyticsReady = true;
+        console.log('[Constellation] Advanced analytics computed:', {
+            pageRankNodes: analyticsPageRank.size,
+            communities: new Set(analyticsCommunities.communities.values()).size,
+            modularity: analyticsCommunities.modularity.toFixed(3),
+            networkHealth: analyticsNetworkHealth
+        });
+    } catch (e) {
+        console.warn('[Constellation] Analytics computation failed, falling back to basic mode:', e);
+        analyticsReady = false;
+    }
+
     renderFeaturedCards(constellation.nodes, profilesData);
     renderFiltersAndLegend(constellation.nodes);
     renderChapterTimeline(lifeChaptersData);
@@ -258,6 +345,14 @@ export async function initConstellation() {
     initSearchAutocomplete(constellation.nodes, profilesData);
     renderNetworkChart(data.temporal_network, data.person_arc);
     renderNetworkInsights(data.temporal_network, constellation, data.person_arc);
+
+    // â”€â”€â”€ Advanced Analytics Sections â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+    if (analyticsReady) {
+        renderNetworkHealthDashboard();
+        renderAdvancedMetrics(constellation);
+        renderCommunityCards();
+        renderDiversityChart();
+    }
 }
 
 // Get the best first_year for a person by merging all sources
@@ -762,16 +857,35 @@ function renderForceGraph(constellation, profiles, coOccurrences) {
                 : Math.max(baseRadius * 0.5, 2.5);
             const displayCat = getDisplayCat(n);
 
+            // Analytics-enhanced sizing
+            const personScore = analyticsPersonScores.get(n.name);
+            const prBoost = analyticsReady && personScore
+                ? personScore.socialGravity * 8 : 0;
+            const analyticsRadius = hasContent
+                ? Math.max(baseRadius + mentionBoost + ecdBoost + prBoost, 5)
+                : Math.max(baseRadius * 0.5, 2.5);
+
+            // Community assignment
+            const communityId = analyticsCommunities.communities.get(n.name);
+            const communityColor = analyticsCommunities.communityColors.get(communityId);
+
             return {
                 ...n, name: n.name,
-                radius: Math.min(nodeRadius, 20),
+                radius: Math.min(analyticsRadius, 24),
                 color: CAT_COLORS[displayCat] || CAT_COLORS.other,
+                communityColor: communityColor || null,
+                communityId: communityId ?? -1,
                 richness: r, hasContent, relation, connection,
                 firstYear, lastYear, totalMentions, importanceScore,
                 peakYear: arc?.peak_year || person?.peak_year || null,
                 activeYears: person?.active_years || '',
                 dominantTopic: person?.dominant_topic || '',
-                displayCat
+                displayCat,
+                pageRank: analyticsPageRank.get(n.name) || 0,
+                betweenness: analyticsBetweenness.get(n.name) || 0,
+                clusteringCoeff: analyticsClustering.get(n.name) || 0,
+                socialGravity: personScore?.socialGravity || 0,
+                percentile: personScore?.percentile || 0
             };
         });
 
@@ -1014,6 +1128,22 @@ function renderForceGraph(constellation, profiles, coOccurrences) {
             showEdgePanel(d, event);
         });
 
+    // â”€â”€ SVG: Community glow halos (behind nodes) â”€â”€
+    if (analyticsReady) {
+        svg.append('g').attr('class', 'community-halos')
+            .selectAll('circle').data(nodes.filter(n => n.percentile >= 75 && n.id !== 'john'))
+            .join('circle')
+            .attr('cx', d => d.x)
+            .attr('cy', d => d.y)
+            .attr('r', d => d.radius + 6)
+            .attr('fill', 'none')
+            .attr('stroke', d => d.communityColor || d.color)
+            .attr('stroke-width', 1.5)
+            .attr('opacity', 0.2)
+            .attr('stroke-dasharray', '2,3')
+            .attr('pointer-events', 'none');
+    }
+
     // â”€â”€ SVG: Nodes â”€â”€
     svgNode = svg.append('g')
         .selectAll('circle')
@@ -1023,10 +1153,23 @@ function renderForceGraph(constellation, profiles, coOccurrences) {
         .attr('cy', d => d.y)
         .attr('r', d => d.radius)
         .attr('fill', d => d.color)
-        .attr('stroke', d => d.hasContent ? 'rgba(255,255,255,0.45)' : 'rgba(255,255,255,0.1)')
-        .attr('stroke-width', d => d.hasContent ? 1.5 : 0.5)
+        .attr('stroke', d => {
+            if (d.percentile >= 90) return 'rgba(201,168,76,0.7)';
+            if (d.hasContent) return 'rgba(255,255,255,0.45)';
+            return 'rgba(255,255,255,0.1)';
+        })
+        .attr('stroke-width', d => {
+            if (d.percentile >= 90) return 2.5;
+            if (d.hasContent) return 1.5;
+            return 0.5;
+        })
         .attr('opacity', d => d.hasContent ? 1 : 0.3)
         .attr('cursor', 'pointer')
+        .attr('class', d => {
+            if (d.percentile >= 90) return 'node-hub';
+            if (d.percentile >= 70) return 'node-important';
+            return '';
+        })
         .call(d3.drag()
             .on('start', dragstarted)
             .on('drag', dragged)
@@ -1074,6 +1217,15 @@ function renderForceGraph(constellation, profiles, coOccurrences) {
         }
         const summary = richnessSummary(d.richness);
         if (summary) parts.push(`<span class="tooltip-richness">${summary}</span>`);
+        // Analytics metrics in tooltip
+        if (analyticsReady && d.id !== 'john') {
+            if (d.pageRank > 0.01)
+                parts.push(`<span class="tooltip-richness">PageRank: ${(d.pageRank * 100).toFixed(1)}%</span>`);
+            if (d.betweenness > 0.01)
+                parts.push(`<span class="tooltip-richness">Bridge Score: ${(d.betweenness * 100).toFixed(1)}%</span>`);
+            if (d.percentile > 0)
+                parts.push(`<span class="tooltip-richness">Top ${100 - d.percentile}% Â· Social Gravity: ${(d.socialGravity * 100).toFixed(0)}</span>`);
+        }
         tooltip
             .style('display', 'block')
             .style('left', (event.offsetX + 12) + 'px')
@@ -1202,6 +1354,36 @@ function showEdgePanel(link, event) {
         html += `<div class="edge-panel-moment" style="color:var(--lj-text-secondary);font-style:italic">Connected in the constellation, but their shared story hasn't been documented yet.</div>`;
     }
 
+    // Analytics: Relationship Strength
+    if (analyticsReady) {
+        const [sA, sB] = nameA < nameB ? [nameA, nameB] : [nameB, nameA];
+        const relKey = `${sA}|${sB}`;
+        const relStr = analyticsRelStrength.get(relKey);
+        const scoreA = analyticsPersonScores.get(nameA);
+        const scoreB = analyticsPersonScores.get(nameB);
+
+        html += `<div class="edge-strength-section">`;
+        html += `<div class="edge-strength-label">Relationship Analytics</div>`;
+        html += `<div class="edge-strength-grid">`;
+        if (relStr) {
+            const classification = relStr.strength > 2 ? 'Strong' :
+                relStr.strength > 1 ? 'Moderate' :
+                relStr.strength > 0.3 ? 'Weak' : 'Dormant';
+            const classColor = relStr.strength > 2 ? '#4a90d9' :
+                relStr.strength > 1 ? '#c9a84c' :
+                relStr.strength > 0.3 ? '#7a8fa6' : '#b45050';
+            html += `<div class="edge-stat"><span class="edge-stat-label">Strength</span><span class="edge-stat-value" style="color:${classColor}">${relStr.strength.toFixed(2)}</span></div>`;
+            html += `<div class="edge-stat"><span class="edge-stat-label">Class</span><span class="edge-stat-value" style="color:${classColor}">${classification}</span></div>`;
+            html += `<div class="edge-stat"><span class="edge-stat-label">Recency</span><span class="edge-stat-value">${(relStr.recency * 100).toFixed(0)}%</span></div>`;
+            html += `<div class="edge-stat"><span class="edge-stat-label">Mutual Ties</span><span class="edge-stat-value">${relStr.mutualCount}</span></div>`;
+        }
+        if (scoreA && scoreB) {
+            html += `<div class="edge-stat"><span class="edge-stat-label">${nameA.split(' ')[0]} Rank</span><span class="edge-stat-value">Top ${100 - scoreA.percentile}%</span></div>`;
+            html += `<div class="edge-stat"><span class="edge-stat-label">${nameB.split(' ')[0]} Rank</span><span class="edge-stat-value">Top ${100 - scoreB.percentile}%</span></div>`;
+        }
+        html += `</div></div>`;
+    }
+
     // View full profile buttons
     html += `<div style="display:flex;gap:6px;margin-top:12px">`;
     html += `<button class="edge-panel-view-btn" data-name="${nameA}">${nameA}</button>`;
@@ -1327,6 +1509,73 @@ function showPersonPanel(d) {
         html += `<div class="person-meta-row">${metaParts.join(' Â· ')}</div>`;
     }
 
+    // â”€â”€â”€ Analytics: Score Donut + Percentile Badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+    if (analyticsReady && d.id !== 'john') {
+        const personScore = analyticsPersonScores.get(d.name);
+        if (personScore) {
+            const pct = personScore.percentile;
+            const gravity = (personScore.socialGravity * 100).toFixed(0);
+            const tierClass = pct >= 90 ? 'top-10' : pct >= 75 ? 'top-25' : pct >= 50 ? 'top-50' : 'bottom-half';
+            const tierLabel = pct >= 90 ? 'Inner Constellation' : pct >= 75 ? 'Close Orbit' : pct >= 50 ? 'Mid Orbit' : 'Outer Ring';
+
+            // Score donut
+            const circumference = 2 * Math.PI * 24;
+            const dashOffset = circumference * (1 - personScore.socialGravity);
+            const donutColor = pct >= 90 ? '#c9a84c' : pct >= 75 ? '#4a90d9' : pct >= 50 ? '#6b4a8b' : '#7a8fa6';
+
+            html += `<div class="score-donut-section">
+                <svg class="score-donut-svg" viewBox="0 0 56 56">
+                    <circle cx="28" cy="28" r="24" fill="none" stroke="rgba(30,58,95,0.3)" stroke-width="4" />
+                    <circle cx="28" cy="28" r="24" fill="none" stroke="${donutColor}" stroke-width="4"
+                        stroke-dasharray="${circumference}" stroke-dashoffset="${dashOffset}"
+                        stroke-linecap="round" />
+                </svg>
+                <div class="score-donut-text">
+                    <div class="score-donut-value">${gravity}</div>
+                    <div class="score-donut-label">Social Gravity Score</div>
+                    <div class="score-donut-rank">${tierLabel} Â· Top ${100 - pct}%</div>
+                </div>
+            </div>`;
+
+            // Percentile badge
+            html += `<span class="percentile-badge ${tierClass}">${tierLabel}</span>`;
+        }
+    }
+
+    // â”€â”€â”€ Analytics: Social DNA Radar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+    if (analyticsReady && d.id !== 'john') {
+        const personScore = analyticsPersonScores.get(d.name);
+        if (personScore) {
+            html += `<div class="social-dna-section">
+                <div class="social-dna-title">Social DNA</div>
+                <canvas class="social-dna-canvas" id="dnaCanvas-${d.name.replace(/[^a-zA-Z0-9]/g, '_')}" width="240" height="240"></canvas>
+                <div class="social-dna-labels">
+                    <span class="dna-label">PageRank: <span class="dna-value">${(personScore.pageRank * 100).toFixed(1)}</span></span>
+                    <span class="dna-label">Bridge: <span class="dna-value">${(personScore.betweenness * 100).toFixed(1)}</span></span>
+                    <span class="dna-label">Clique: <span class="dna-value">${(personScore.clustering * 100).toFixed(1)}</span></span>
+                    <span class="dna-label">Activity: <span class="dna-value">${(personScore.mentions * 100).toFixed(1)}</span></span>
+                    <span class="dna-label">Longevity: <span class="dna-value">${(personScore.span * 100).toFixed(1)}</span></span>
+                </div>
+            </div>`;
+        }
+    }
+
+    // â”€â”€â”€ Analytics: Activity Sparkline â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+    if (d.id !== 'john' && (profile?.timeline?.length || arc?.first_year)) {
+        const sparkFirstYear = firstYear || 2004;
+        const sparkLastYear = lastYear || 2026;
+        html += `<div class="sparkline-section">
+            <div class="sparkline-label">Activity Over Time</div>
+            <div class="sparkline-container">
+                <canvas class="sparkline-canvas" id="sparkline-${d.name.replace(/[^a-zA-Z0-9]/g, '_')}" width="340" height="48"></canvas>
+            </div>
+            <div class="sparkline-range">
+                <span>${sparkFirstYear}</span>
+                <span>${sparkLastYear}</span>
+            </div>
+        </div>`;
+    }
+
     // Connections with mutual friend counts
     if (connected.length) {
         // Build connection set for selected person (excluding hub to John)
@@ -1524,6 +1773,27 @@ function showPersonPanel(d) {
             focusNodeByName(tag.dataset.name);
         });
     });
+
+    // â”€â”€â”€ Draw Social DNA Radar Chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+    if (analyticsReady && d.id !== 'john') {
+        const personScore = analyticsPersonScores.get(d.name);
+        if (personScore) {
+            requestAnimationFrame(() => {
+                const canvasId = `dnaCanvas-${d.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
+                const canvas = document.getElementById(canvasId);
+                if (canvas) drawRadarChart(canvas, personScore);
+            });
+        }
+    }
+
+    // â”€â”€â”€ Draw Activity Sparkline â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+    if (d.id !== 'john') {
+        requestAnimationFrame(() => {
+            const sparkId = `sparkline-${d.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
+            const canvas = document.getElementById(sparkId);
+            if (canvas) drawSparkline(canvas, d, profile);
+        });
+    }
 }
 
 function closeSidebar() {
@@ -1872,6 +2142,547 @@ function renderNetworkInsights(temporalNetwork, constellation, personArc) {
     });
 }
 
+// â”€â”€â”€ Radar Chart Drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+// Draws a pentagon radar chart on a canvas for a person's social DNA.
+
+function drawRadarChart(canvas, scores) {
+    const ctx = canvas.getContext('2d');
+    const w = canvas.width;
+    const h = canvas.height;
+    const cx = w / 2;
+    const cy = h / 2;
+    const r = Math.min(w, h) * 0.38;
+
+    const dims = [
+        { key: 'pageRank', label: 'Influence' },
+        { key: 'betweenness', label: 'Bridge' },
+        { key: 'clustering', label: 'Clique' },
+        { key: 'mentions', label: 'Activity' },
+        { key: 'span', label: 'Longevity' }
+    ];
+    const n = dims.length;
+    const angleStep = (2 * Math.PI) / n;
+    const startAngle = -Math.PI / 2; // top
+
+    ctx.clearRect(0, 0, w, h);
+
+    // Draw grid rings
+    for (let ring = 1; ring <= 4; ring++) {
+        const rr = (ring / 4) * r;
+        ctx.beginPath();
+        for (let i = 0; i <= n; i++) {
+            const a = startAngle + i * angleStep;
+            const x = cx + rr * Math.cos(a);
+            const y = cy + rr * Math.sin(a);
+            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
+        }
+        ctx.closePath();
+        ctx.strokeStyle = 'rgba(30, 58, 95, 0.3)';
+        ctx.lineWidth = 0.5;
+        ctx.stroke();
+    }
+
+    // Draw axis lines
+    for (let i = 0; i < n; i++) {
+        const a = startAngle + i * angleStep;
+        ctx.beginPath();
+        ctx.moveTo(cx, cy);
+        ctx.lineTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
+        ctx.strokeStyle = 'rgba(30, 58, 95, 0.25)';
+        ctx.lineWidth = 0.5;
+        ctx.stroke();
+    }
+
+    // Draw data polygon
+    ctx.beginPath();
+    for (let i = 0; i < n; i++) {
+        const val = scores[dims[i].key] || 0;
+        const a = startAngle + i * angleStep;
+        const x = cx + r * val * Math.cos(a);
+        const y = cy + r * val * Math.sin(a);
+        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
+    }
+    ctx.closePath();
+    ctx.fillStyle = 'rgba(74, 144, 217, 0.15)';
+    ctx.fill();
+    ctx.strokeStyle = 'rgba(74, 144, 217, 0.8)';
+    ctx.lineWidth = 1.5;
+    ctx.stroke();
+
+    // Draw data points
+    for (let i = 0; i < n; i++) {
+        const val = scores[dims[i].key] || 0;
+        const a = startAngle + i * angleStep;
+        const x = cx + r * val * Math.cos(a);
+        const y = cy + r * val * Math.sin(a);
+        ctx.beginPath();
+        ctx.arc(x, y, 3, 0, 2 * Math.PI);
+        ctx.fillStyle = '#4a90d9';
+        ctx.fill();
+    }
+
+    // Draw dimension labels
+    ctx.font = '9px Trebuchet MS, sans-serif';
+    ctx.fillStyle = '#7a8fa6';
+    ctx.textAlign = 'center';
+    ctx.textBaseline = 'middle';
+    for (let i = 0; i < n; i++) {
+        const a = startAngle + i * angleStep;
+        const lx = cx + (r + 16) * Math.cos(a);
+        const ly = cy + (r + 16) * Math.sin(a);
+        ctx.fillText(dims[i].label, lx, ly);
+    }
+}
+
+// â”€â”€â”€ Sparkline Drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+// Draws a mini bar chart of activity per year.
+
+function drawSparkline(canvas, personData, profile) {
+    const ctx = canvas.getContext('2d');
+    const w = canvas.width;
+    const h = canvas.height;
+
+    ctx.clearRect(0, 0, w, h);
+
+    // Count events per year
+    const eventsByYear = {};
+    const timeline = profile?.timeline || [];
+    timeline.forEach(e => {
+        if (e.year) eventsByYear[e.year] = (eventsByYear[e.year] || 0) + 1;
+    });
+
+    // Also count co-occurrences
+    (coOccurrencesData || []).forEach(co => {
+        if ((co.person_a === personData.name || co.person_b === personData.name) && co.year) {
+            eventsByYear[co.year] = (eventsByYear[co.year] || 0) + 0.5;
+        }
+    });
+
+    const startYear = personData.firstYear || 2004;
+    const endYear = personData.lastYear || 2026;
+    const years = [];
+    for (let y = startYear; y <= endYear; y++) years.push(y);
+
+    if (!years.length) return;
+
+    const values = years.map(y => eventsByYear[y] || 0);
+    const maxVal = Math.max(...values, 1);
+    const barW = Math.max(w / years.length - 1, 2);
+    const gap = (w - barW * years.length) / (years.length + 1);
+
+    for (let i = 0; i < years.length; i++) {
+        const barH = (values[i] / maxVal) * (h - 4);
+        const x = gap + i * (barW + gap);
+        const y = h - barH - 2;
+
+        const isPeak = personData.peakYear === years[i];
+        ctx.fillStyle = isPeak ? 'rgba(201, 168, 76, 0.9)' :
+            values[i] > 0 ? 'rgba(74, 144, 217, 0.6)' : 'rgba(30, 58, 95, 0.2)';
+        ctx.fillRect(x, y, barW, barH);
+    }
+}
+
+// â”€â”€â”€ Network Health Dashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+// Renders circular ring indicators for network health metrics.
+
+function renderNetworkHealthDashboard() {
+    const mount = document.getElementById('networkHealthMount');
+    if (!mount || !analyticsReady) return;
+
+    const h = analyticsNetworkHealth;
+
+    const metrics = [
+        {
+            value: h.avgDegree?.toFixed(1) || '0',
+            pct: Math.min((h.avgDegree || 0) / 10, 1),
+            label: 'Avg Connections',
+            sublabel: 'per person',
+            color: '#4a90d9'
+        },
+        {
+            value: ((h.density || 0) * 100).toFixed(1) + '%',
+            pct: h.density || 0,
+            label: 'Network Density',
+            sublabel: 'of possible edges',
+            color: '#4a6741'
+        },
+        {
+            value: ((h.avgClusteringCoeff || 0) * 100).toFixed(0) + '%',
+            pct: h.avgClusteringCoeff || 0,
+            label: 'Clustering',
+            sublabel: 'avg clique tightness',
+            color: '#6b4a8b'
+        },
+        {
+            value: h.giantComponentSize || 0,
+            pct: Math.min((h.giantComponentSize || 0) / (allNodes.length || 1), 1),
+            label: 'Giant Component',
+            sublabel: 'largest connected group',
+            color: '#c9a84c'
+        },
+        {
+            value: (h.avgPathLength || 0).toFixed(1),
+            pct: Math.min((h.avgPathLength || 0) / 5, 1),
+            label: 'Avg Path Length',
+            sublabel: 'hops between people',
+            color: '#4a90d9'
+        },
+        {
+            value: ((h.activeRatio || 0) * 100).toFixed(0) + '%',
+            pct: h.activeRatio || 0,
+            label: 'Still Active',
+            sublabel: 'in last 3 years',
+            color: '#4a6741'
+        },
+        {
+            value: ((h.churnRate || 0) * 100).toFixed(0) + '%',
+            pct: h.churnRate || 0,
+            label: 'Faded Away',
+            sublabel: 'inactive 5+ years',
+            color: '#b45050'
+        },
+        {
+            value: ((h.networkCentralization || 0) * 100).toFixed(0) + '%',
+            pct: Math.min(h.networkCentralization || 0, 1),
+            label: 'Centralization',
+            sublabel: 'how star-shaped',
+            color: '#7a8fa6'
+        }
+    ];
+
+    mount.innerHTML = metrics.map(m => {
+        const circumference = 2 * Math.PI * 22;
+        const dashOffset = circumference * (1 - m.pct);
+        return `<div class="health-card">
+            <div class="health-card-ring">
+                <svg viewBox="0 0 52 52">
+                    <circle cx="26" cy="26" r="22" fill="none" stroke="rgba(30,58,95,0.3)" stroke-width="4" />
+                    <circle cx="26" cy="26" r="22" fill="none" stroke="${m.color}" stroke-width="4"
+                        stroke-dasharray="${circumference}" stroke-dashoffset="${dashOffset}"
+                        stroke-linecap="round" style="transform:rotate(-90deg);transform-origin:center;" />
+                </svg>
+                <div class="health-card-ring-value">${m.value}</div>
+            </div>
+            <div class="health-card-label">${m.label}</div>
+            <div class="health-card-sublabel">${m.sublabel}</div>
+        </div>`;
+    }).join('');
+}
+
+// â”€â”€â”€ Advanced Metrics Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+// Shows top PageRank, bridge people, clique leaders, etc.
+
+function renderAdvancedMetrics(constellation) {
+    const mount = document.getElementById('metricsGridMount');
+    if (!mount || !analyticsReady) return;
+
+    const nodes = allNodes.filter(n => n.id !== 'john');
+
+    // Top PageRank people
+    const topPR = [...analyticsPageRank.entries()]
+        .filter(([name]) => name !== 'John Tronolone')
+        .sort((a, b) => b[1] - a[1]).slice(0, 5);
+
+    // Top bridge people (betweenness)
+    const topBridge = [...analyticsBetweenness.entries()]
+        .filter(([name]) => name !== 'John Tronolone')
+        .sort((a, b) => b[1] - a[1]).slice(0, 5);
+
+    // Highest clustering (clique leaders)
+    const topClique = [...analyticsClustering.entries()]
+        .filter(([name]) => name !== 'John Tronolone')
+        .sort((a, b) => b[1] - a[1]).slice(0, 5);
+
+    // Strongest relationships
+    const topRels = [...analyticsRelStrength.entries()]
+        .sort((a, b) => b[1].strength - a[1].strength).slice(0, 5);
+
+    const communityCount = new Set(analyticsCommunities.communities.values()).size;
+
+    let html = '';
+
+    // Summary cards
+    html += `<div class="metric-card">
+        <div class="metric-card-icon">ğŸ§ </div>
+        <div class="metric-card-value">${communityCount}</div>
+        <div class="metric-card-label">Natural Communities</div>
+        <div class="metric-card-detail">Detected via modularity optimization (Q=${analyticsCommunities.modularity.toFixed(3)})</div>
+        <div class="metric-card-bar" style="width:${Math.min(communityCount / 10 * 100, 100)}%"></div>
+    </div>`;
+
+    html += `<div class="metric-card">
+        <div class="metric-card-icon">â­</div>
+        <div class="metric-card-value">${topPR.length ? topPR[0][0].split(' ')[0] : 'â€”'}</div>
+        <div class="metric-card-label">Highest PageRank</div>
+        <div class="metric-card-detail">${topPR.length ? `Score: ${(topPR[0][1] * 100).toFixed(1)}% â€” most central by link structure` : 'N/A'}</div>
+        <div class="metric-card-bar" style="width:${topPR.length ? topPR[0][1] * 100 : 0}%"></div>
+    </div>`;
+
+    html += `<div class="metric-card">
+        <div class="metric-card-icon">ğŸŒ‰</div>
+        <div class="metric-card-value">${topBridge.length ? topBridge[0][0].split(' ')[0] : 'â€”'}</div>
+        <div class="metric-card-label">Top Bridge Person</div>
+        <div class="metric-card-detail">${topBridge.length ? `Betweenness: ${(topBridge[0][1] * 100).toFixed(1)}% â€” connects separate clusters` : 'N/A'}</div>
+        <div class="metric-card-bar" style="width:${topBridge.length ? topBridge[0][1] * 100 : 0}%"></div>
+    </div>`;
+
+    html += `<div class="metric-card">
+        <div class="metric-card-icon">ğŸ”—</div>
+        <div class="metric-card-value">${topClique.length ? topClique[0][0].split(' ')[0] : 'â€”'}</div>
+        <div class="metric-card-label">Tightest Clique</div>
+        <div class="metric-card-detail">${topClique.length ? `Clustering: ${(topClique[0][1] * 100).toFixed(0)}% â€” neighbors are also friends` : 'N/A'}</div>
+        <div class="metric-card-bar" style="width:${topClique.length ? topClique[0][1] * 100 : 0}%"></div>
+    </div>`;
+
+    // Top lists
+    html += `</div>`; // close metrics-grid
+    html += `<div class="insights-grid" style="margin-top:20px">`;
+
+    // PageRank leaders
+    html += `<div class="insights-section">
+        <h4 class="insights-section-title">PageRank Leaders</h4>
+        <p class="insights-desc">Who matters most by network structure alone</p>
+        <div class="insights-list">${topPR.map(([name, score]) => {
+            const person = peopleData[name];
+            return `<button class="insight-person" data-name="${name}">
+                <span class="insight-person-name">${name}</span>
+                <span class="insight-person-meta">${(score * 100).toFixed(1)}%${person?.relation ? ' Â· ' + person.relation : ''}</span>
+            </button>`;
+        }).join('')}</div>
+    </div>`;
+
+    // Bridge people
+    html += `<div class="insights-section">
+        <h4 class="insights-section-title">Bridge People</h4>
+        <p class="insights-desc">Connectors between different social clusters</p>
+        <div class="insights-list">${topBridge.map(([name, score]) => {
+            const person = peopleData[name];
+            return `<button class="insight-person" data-name="${name}">
+                <span class="insight-person-name">${name}</span>
+                <span class="insight-person-meta">${(score * 100).toFixed(1)}%${person?.relation ? ' Â· ' + person.relation : ''}</span>
+            </button>`;
+        }).join('')}</div>
+    </div>`;
+
+    // Strongest bonds
+    html += `<div class="insights-section">
+        <h4 class="insights-section-title">Strongest Bonds</h4>
+        <p class="insights-desc">Relationships with highest composite strength (weight + co-occurrence + recency)</p>
+        <div class="insights-list">${topRels.map(([key, data]) => {
+            const [nameA, nameB] = key.split('|');
+            const classification = data.strength > 2 ? 'Strong' : data.strength > 1 ? 'Moderate' : 'Weak';
+            return `<button class="insight-person" data-name="${nameA}">
+                <span class="insight-person-name">${nameA} â†” ${nameB}</span>
+                <span class="insight-person-meta">${data.strength.toFixed(2)} Â· ${classification} Â· ${data.mutualCount} mutual</span>
+            </button>`;
+        }).join('')}</div>
+    </div>`;
+
+    html += `</div>`;
+
+    mount.innerHTML = html;
+
+    // Wire up clickable people
+    mount.querySelectorAll('.insight-person').forEach(btn => {
+        btn.addEventListener('click', () => {
+            focusNodeByName(btn.dataset.name);
+            document.getElementById('constellationMount')?.scrollIntoView({ behavior: 'smooth', block: 'center' });
+        });
+    });
+}
+
+// â”€â”€â”€ Community Cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+// Renders detected community clusters with member lists.
+
+function renderCommunityCards() {
+    const mount = document.getElementById('communitiesMount');
+    if (!mount || !analyticsReady) return;
+
+    const communityMembers = {};
+    for (const [name, communityId] of analyticsCommunities.communities) {
+        if (name === 'John Tronolone') continue;
+        if (!communityMembers[communityId]) communityMembers[communityId] = [];
+        communityMembers[communityId].push(name);
+    }
+
+    // Sort communities by size
+    const sortedCommunities = Object.entries(communityMembers)
+        .map(([id, members]) => ({
+            id: parseInt(id),
+            members: members.sort((a, b) => {
+                const scoreA = analyticsPersonScores.get(a)?.socialGravity || 0;
+                const scoreB = analyticsPersonScores.get(b)?.socialGravity || 0;
+                return scoreB - scoreA;
+            })
+        }))
+        .filter(c => c.members.length >= 2) // Only show communities with 2+ members
+        .sort((a, b) => b.members.length - a.members.length);
+
+    if (!sortedCommunities.length) return;
+
+    // Name communities by their top member's category
+    function nameCommunity(members) {
+        const catCounts = {};
+        members.forEach(name => {
+            const node = allNodes.find(n => n.name === name);
+            const cat = node?.displayCat || 'other';
+            catCounts[cat] = (catCounts[cat] || 0) + 1;
+        });
+        const topCat = Object.entries(catCounts).sort((a, b) => b[1] - a[1])[0]?.[0];
+        const catNames = { core: 'Inner Circle', family: 'Family', ecd: 'ECD Community', other: 'Extended Network' };
+        const topMember = members[0]?.split(' ')[0] || '';
+        return `${catNames[topCat] || 'Group'} (${topMember}+)`;
+    }
+
+    let html = `<h4 class="insights-section-title">Detected Communities</h4>
+        <p class="insights-desc">Clusters discovered by modularity optimization â€” groups that naturally hang together</p>
+        <div class="communities-grid">`;
+
+    sortedCommunities.forEach(c => {
+        const color = analyticsCommunities.communityColors.get(c.id) || '#7a8fa6';
+        const communityName = nameCommunity(c.members);
+
+        // Community-level stats
+        const avgPR = c.members.reduce((sum, m) => sum + (analyticsPageRank.get(m) || 0), 0) / c.members.length;
+        const avgCC = c.members.reduce((sum, m) => sum + (analyticsClustering.get(m) || 0), 0) / c.members.length;
+
+        html += `<div class="community-card" style="--community-color:${color}">
+            <div class="community-card-header">
+                <span class="community-dot" style="background:${color}"></span>
+                <span class="community-name">${communityName}</span>
+                <span class="community-count">${c.members.length}</span>
+            </div>
+            <div class="community-members">${c.members.slice(0, 12).map(name =>
+                `<button class="community-member" data-name="${name}">${name}</button>`
+            ).join('')}${c.members.length > 12 ? `<span class="community-member" style="cursor:default;opacity:0.5">+${c.members.length - 12} more</span>` : ''}</div>
+            <div class="community-stats">
+                <span>Avg PageRank: ${(avgPR * 100).toFixed(1)}%</span>
+                <span>Avg Clustering: ${(avgCC * 100).toFixed(0)}%</span>
+            </div>
+        </div>`;
+    });
+
+    html += `</div>`;
+    mount.innerHTML = html;
+
+    // Wire up member clicks
+    mount.querySelectorAll('.community-member[data-name]').forEach(btn => {
+        btn.addEventListener('click', () => {
+            focusNodeByName(btn.dataset.name);
+            document.getElementById('constellationMount')?.scrollIntoView({ behavior: 'smooth', block: 'center' });
+        });
+    });
+}
+
+// â”€â”€â”€ Diversity Over Time Chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+// Shannon entropy of category mix + network age over time.
+
+function renderDiversityChart() {
+    const canvas = document.getElementById('diversityChart');
+    if (!canvas || typeof Chart === 'undefined' || !analyticsReady) return;
+
+    const evolution = analyticsTemporalEvolution;
+    if (!evolution.length) return;
+
+    const years = evolution.map(e => String(e.year));
+    const diversity = evolution.map(e => e.diversityIndex);
+    const networkAge = evolution.map(e => e.networkAge);
+    const activeCount = evolution.map(e => e.activeCount);
+
+    new Chart(canvas, {
+        type: 'line',
+        data: {
+            labels: years,
+            datasets: [
+                {
+                    label: 'Diversity Index (Shannon)',
+                    data: diversity,
+                    borderColor: '#6b4a8b',
+                    backgroundColor: 'rgba(107,74,139,0.1)',
+                    fill: true,
+                    tension: 0.3,
+                    pointRadius: 3,
+                    pointBackgroundColor: '#6b4a8b',
+                    borderWidth: 2,
+                    yAxisID: 'y'
+                },
+                {
+                    label: 'Network Age (avg years known)',
+                    data: networkAge,
+                    borderColor: '#c9a84c',
+                    backgroundColor: 'rgba(201,168,76,0.05)',
+                    fill: false,
+                    tension: 0.3,
+                    pointRadius: 3,
+                    pointBackgroundColor: '#c9a84c',
+                    borderWidth: 2,
+                    yAxisID: 'y1'
+                },
+                {
+                    label: 'Active People',
+                    data: activeCount,
+                    borderColor: 'rgba(74,144,217,0.4)',
+                    backgroundColor: 'rgba(74,144,217,0.08)',
+                    fill: true,
+                    tension: 0.3,
+                    pointRadius: 2,
+                    borderWidth: 1,
+                    borderDash: [4, 4],
+                    yAxisID: 'y1'
+                }
+            ]
+        },
+        options: {
+            responsive: true,
+            interaction: { mode: 'index', intersect: false },
+            plugins: {
+                legend: {
+                    display: true,
+                    position: 'bottom',
+                    labels: {
+                        color: '#7a8fa6',
+                        font: { family: "'Trebuchet MS', sans-serif", size: 11 },
+                        boxWidth: 14,
+                        padding: 16
+                    }
+                },
+                tooltip: {
+                    backgroundColor: 'rgba(10, 22, 40, 0.95)',
+                    borderColor: '#6b4a8b',
+                    borderWidth: 1,
+                    titleFont: { family: "'Courier Prime', monospace", size: 13 },
+                    bodyFont: { family: "'Trebuchet MS', sans-serif", size: 12 },
+                    padding: 12
+                }
+            },
+            scales: {
+                x: {
+                    ticks: { color: '#7a8fa6', font: { family: "'Courier Prime', monospace", size: 10 } },
+                    grid: { color: 'rgba(30,58,95,0.2)' }
+                },
+                y: {
+                    position: 'left',
+                    title: {
+                        display: true, text: 'Shannon Entropy',
+                        color: '#6b4a8b', font: { family: "'Courier Prime', monospace", size: 10 }
+                    },
+                    ticks: { color: '#6b4a8b', font: { family: "'Courier Prime', monospace", size: 10 } },
+                    grid: { color: 'rgba(30,58,95,0.15)' }
+                },
+                y1: {
+                    position: 'right',
+                    title: {
+                        display: true, text: 'People / Years',
+                        color: '#c9a84c', font: { family: "'Courier Prime', monospace", size: 10 }
+                    },
+                    ticks: { color: '#c9a84c', font: { family: "'Courier Prime', monospace", size: 10 } },
+                    grid: { drawOnChartArea: false }
+                }
+            }
+        }
+    });
+}
+
 // Auto-init
 initConstellation()
     .then(() => initWormholes('constellation'))
diff --git a/timeline-of-tron/js/graph-analytics.js b/timeline-of-tron/js/graph-analytics.js
new file mode 100644
index 0000000..778bf7d
--- /dev/null
+++ b/timeline-of-tron/js/graph-analytics.js
@@ -0,0 +1,944 @@
+/**
+ * Graph Analytics Module
+ * Advanced graph theory algorithms for constellation network analysis
+ * Implements PageRank, betweenness centrality, clustering, community detection, etc.
+ *
+ * No external dependencies â€” pure JavaScript implementation
+ */
+
+/**
+ * Extracts name from node identifier (handles both string and object forms)
+ * @param {string|{name: string}} node
+ * @returns {string}
+ */
+function getName(node) {
+  return typeof node === 'string' ? node : node.name;
+}
+
+/**
+ * Normalizes a map of scores to 0-1 range
+ * @param {Map} scoreMap
+ * @returns {Map}
+ */
+function normalizeScores(scoreMap) {
+  const values = Array.from(scoreMap.values());
+  if (values.length === 0) return new Map();
+
+  const min = Math.min(...values);
+  const max = Math.max(...values);
+  const range = max - min || 1;
+
+  const normalized = new Map();
+  for (const [key, value] of scoreMap) {
+    normalized.set(key, (value - min) / range);
+  }
+  return normalized;
+}
+
+/**
+ * Builds adjacency list from nodes and links
+ * Handles both string and object node references
+ * @param {Array} nodes
+ * @param {Array} links
+ * @returns {Map<string, Set<string>>}
+ */
+function buildAdjacencyList(nodes, links) {
+  const nodeNames = new Set();
+  for (const node of nodes) {
+    nodeNames.add(getName(node));
+  }
+
+  const adjacency = new Map();
+  for (const name of nodeNames) {
+    adjacency.set(name, new Set());
+  }
+
+  for (const link of links) {
+    const source = getName(link.source);
+    const target = getName(link.target);
+
+    // Skip self-loops
+    if (source === target) continue;
+
+    // Only add if both nodes exist
+    if (nodeNames.has(source) && nodeNames.has(target)) {
+      adjacency.get(source).add(target);
+      adjacency.get(target).add(source); // Undirected graph
+    }
+  }
+
+  return adjacency;
+}
+
+/**
+ * Computes PageRank scores for all nodes
+ * Standard PageRank with damping factor and random teleportation
+ *
+ * @param {Array<{name: string}>} nodes - Array of node objects
+ * @param {Array} links - Array of link objects with source/target
+ * @param {number} damping - Damping factor (0.85 default)
+ * @param {number} iterations - Number of iterations (100 default)
+ * @returns {Map<string, number>} - Map of name â†’ normalized pageRank (0-1)
+ */
+export function computePageRank(nodes, links, damping = 0.85, iterations = 100) {
+  const nodeNames = nodes.map(n => getName(n));
+  const n = nodeNames.length;
+
+  if (n === 0) return new Map();
+
+  const adjacency = buildAdjacencyList(nodes, links);
+
+  // Initialize ranks
+  const ranks = new Map();
+  for (const name of nodeNames) {
+    ranks.set(name, 1 / n);
+  }
+
+  // Compute out-degrees
+  const outDegrees = new Map();
+  for (const name of nodeNames) {
+    const neighbors = adjacency.get(name);
+    outDegrees.set(name, neighbors.size || 1); // Avoid division by zero
+  }
+
+  const teleportValue = (1 - damping) / n;
+
+  // Iterative computation
+  for (let iter = 0; iter < iterations; iter++) {
+    const newRanks = new Map();
+
+    for (const name of nodeNames) {
+      let rank = teleportValue;
+
+      // Sum contributions from incoming edges
+      for (const neighbor of adjacency.get(name)) {
+        rank += damping * (ranks.get(neighbor) / outDegrees.get(neighbor));
+      }
+
+      newRanks.set(name, rank);
+    }
+
+    ranks.clear();
+    for (const [name, rank] of newRanks) {
+      ranks.set(name, rank);
+    }
+  }
+
+  return normalizeScores(ranks);
+}
+
+/**
+ * Computes betweenness centrality using Brandes' algorithm
+ * Measures how often a node appears on shortest paths between other nodes
+ * Identifies "bridge" people connecting different clusters
+ *
+ * @param {Array<{name: string}>} nodes - Array of node objects
+ * @param {Array} links - Array of link objects
+ * @returns {Map<string, number>} - Map of name â†’ normalized betweenness (0-1)
+ */
+export function computeBetweenness(nodes, links) {
+  const nodeNames = nodes.map(n => getName(n));
+  const n = nodeNames.length;
+
+  if (n < 3) return new Map();
+
+  const adjacency = buildAdjacencyList(nodes, links);
+  const betweenness = new Map();
+
+  for (const name of nodeNames) {
+    betweenness.set(name, 0);
+  }
+
+  // For each source node, compute shortest-path DAG and accumulate
+  for (const source of nodeNames) {
+    const distance = new Map();
+    const predecessors = new Map();
+    const sigma = new Map(); // Number of shortest paths
+
+    for (const node of nodeNames) {
+      distance.set(node, node === source ? 0 : Infinity);
+      predecessors.set(node, []);
+      sigma.set(node, 0);
+    }
+    sigma.set(source, 1);
+
+    // BFS to compute shortest paths
+    const queue = [source];
+    const order = [];
+
+    while (queue.length > 0) {
+      const u = queue.shift();
+      order.push(u);
+
+      for (const v of adjacency.get(u)) {
+        // First time finding path to v
+        if (distance.get(v) === Infinity) {
+          distance.set(v, distance.get(u) + 1);
+          queue.push(v);
+        }
+
+        // Shortest path to v via u
+        if (distance.get(v) === distance.get(u) + 1) {
+          sigma.set(v, sigma.get(v) + sigma.get(u));
+          predecessors.get(v).push(u);
+        }
+      }
+    }
+
+    // Accumulation step (backwards)
+    const delta = new Map();
+    for (const node of nodeNames) {
+      delta.set(node, 0);
+    }
+
+    for (let i = order.length - 1; i >= 0; i--) {
+      const w = order[i];
+      for (const v of predecessors.get(w)) {
+        const contribution = (sigma.get(v) / sigma.get(w)) * (1 + delta.get(w));
+        delta.set(v, delta.get(v) + contribution);
+      }
+
+      if (w !== source) {
+        betweenness.set(w, betweenness.get(w) + delta.get(w));
+      }
+    }
+  }
+
+  return normalizeScores(betweenness);
+}
+
+/**
+ * Computes clustering coefficient for each node
+ * Measures how many neighbors are connected to each other (0-1)
+ * High = tight clique; Low = bridges separate groups
+ *
+ * @param {Array<{name: string}>} nodes - Array of node objects
+ * @param {Array} links - Array of link objects
+ * @returns {Map<string, number>} - Map of name â†’ clustering coefficient
+ */
+export function computeClusteringCoeff(nodes, links) {
+  const nodeNames = nodes.map(n => getName(n));
+  const adjacency = buildAdjacencyList(nodes, links);
+  const clustering = new Map();
+
+  for (const node of nodeNames) {
+    const neighbors = Array.from(adjacency.get(node));
+    const k = neighbors.length;
+
+    if (k < 2) {
+      clustering.set(node, 0);
+      continue;
+    }
+
+    // Count edges between neighbors
+    let edges = 0;
+    for (let i = 0; i < neighbors.length; i++) {
+      for (let j = i + 1; j < neighbors.length; j++) {
+        if (adjacency.get(neighbors[i]).has(neighbors[j])) {
+          edges++;
+        }
+      }
+    }
+
+    const maxEdges = (k * (k - 1)) / 2;
+    clustering.set(node, edges / maxEdges);
+  }
+
+  return clustering;
+}
+
+/**
+ * Detects communities using greedy modularity optimization (simplified Louvain)
+ * Identifies clusters of densely-connected nodes
+ *
+ * @param {Array<{name: string}>} nodes - Array of node objects
+ * @param {Array} links - Array of link objects
+ * @returns {{communities: Map<string, number>, modularity: number, communityColors: Map<number, string>}}
+ */
+export function detectCommunities(nodes, links) {
+  const nodeNames = nodes.map(n => getName(n));
+  const adjacency = buildAdjacencyList(nodes, links);
+
+  // Initialize each node in its own community
+  const communities = new Map();
+  for (let i = 0; i < nodeNames.length; i++) {
+    communities.set(nodeNames[i], i);
+  }
+
+  let improved = true;
+  let bestModularity = computeModularity(adjacency, communities, nodeNames.length);
+
+  // Greedy optimization
+  while (improved) {
+    improved = false;
+
+    for (const node of nodeNames) {
+      const currentCommunity = communities.get(node);
+      let bestGain = 0;
+      let bestNewCommunity = currentCommunity;
+
+      // Try moving to each neighbor's community
+      const neighborCommunities = new Set();
+      for (const neighbor of adjacency.get(node)) {
+        neighborCommunities.add(communities.get(neighbor));
+      }
+      neighborCommunities.add(currentCommunity);
+
+      for (const newCommunity of neighborCommunities) {
+        communities.set(node, newCommunity);
+        const newModularity = computeModularity(adjacency, communities, nodeNames.length);
+        const gain = newModularity - bestModularity;
+
+        if (gain > bestGain) {
+          bestGain = gain;
+          bestNewCommunity = newCommunity;
+        }
+      }
+
+      communities.set(node, bestNewCommunity);
+      if (bestGain > 0) {
+        improved = true;
+        bestModularity += bestGain;
+      }
+    }
+  }
+
+  // Assign colors to communities
+  const uniqueCommunities = Array.from(new Set(communities.values())).sort((a, b) => a - b);
+  const palette = [
+    '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A',
+    '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'
+  ];
+
+  const communityColors = new Map();
+  for (let i = 0; i < uniqueCommunities.length; i++) {
+    communityColors.set(uniqueCommunities[i], palette[i % palette.length]);
+  }
+
+  return {
+    communities,
+    modularity: bestModularity,
+    communityColors
+  };
+}
+
+/**
+ * Computes modularity score for current community assignment
+ * Higher score = better community structure
+ *
+ * @private
+ * @param {Map<string, Set<string>>} adjacency
+ * @param {Map<string, number>} communities
+ * @param {number} n
+ * @returns {number}
+ */
+function computeModularity(adjacency, communities, n) {
+  let modularity = 0;
+  const m = Array.from(adjacency.values()).reduce((sum, neighbors) => sum + neighbors.size, 0) / 2;
+
+  if (m === 0) return 0;
+
+  const degree = new Map();
+  for (const [node, neighbors] of adjacency) {
+    degree.set(node, neighbors.size);
+  }
+
+  const communityMap = new Map();
+  for (const [node, community] of communities) {
+    if (!communityMap.has(community)) {
+      communityMap.set(community, []);
+    }
+    communityMap.get(community).push(node);
+  }
+
+  for (const nodes of communityMap.values()) {
+    for (let i = 0; i < nodes.length; i++) {
+      for (let j = i; j < nodes.length; j++) {
+        const u = nodes[i];
+        const v = nodes[j];
+
+        const aij = u === v ? 0 : (adjacency.get(u).has(v) ? 1 : 0);
+        const expected = (degree.get(u) * degree.get(v)) / (2 * m);
+        modularity += aij - expected;
+      }
+    }
+  }
+
+  return modularity / (2 * m);
+}
+
+/**
+ * Computes relationship strength with temporal decay
+ * Combines edge weight, co-occurrences, recency, and mutual connections
+ *
+ * @param {Array<{name: string}>} nodes
+ * @param {Array} links - Links with optional .weight property
+ * @param {Map} coOccurrences - Map of "nameA|nameB" â†’ count
+ * @param {Array} arcData - Array of people with first_year/last_year
+ * @param {number} currentYear - Current year (default 2026)
+ * @returns {Map<string, {strength: number, decay: number, recency: number, mutualCount: number}>}
+ */
+export function computeRelationshipStrength(nodes, links, coOccurrences = new Map(), arcData = [], currentYear = 2026) {
+  const nodeNames = new Set(nodes.map(n => getName(n)));
+  const adjacency = buildAdjacencyList(nodes, links);
+
+  // Build person data map (supports both .name and .person keys)
+  const personData = new Map();
+  for (const person of arcData) {
+    const pName = person.name || person.person;
+    if (pName) personData.set(pName, person);
+  }
+
+  const strengthMap = new Map();
+  const processedPairs = new Set();
+
+  for (const link of links) {
+    const source = getName(link.source);
+    const target = getName(link.target);
+
+    if (source === target) continue;
+    if (!nodeNames.has(source) || !nodeNames.has(target)) continue;
+
+    // Normalize pair key
+    const [nameA, nameB] = source < target ? [source, target] : [target, source];
+    const pairKey = `${nameA}|${nameB}`;
+
+    if (processedPairs.has(pairKey)) continue;
+    processedPairs.add(pairKey);
+
+    let strength = link.weight || 1;
+
+    // Co-occurrence bonus
+    const coOccCount = coOccurrences.get(pairKey) || 0;
+    strength += coOccCount * 0.3;
+
+    // Temporal recency decay
+    let recency = 1;
+    const personA = personData.get(nameA);
+    const personB = personData.get(nameB);
+
+    if (personA && personB) {
+      const lastYear = Math.max(personA.last_year || currentYear, personB.last_year || currentYear);
+      const yearsSinceActive = currentYear - lastYear;
+      const halfLife = 4;
+      recency = Math.pow(0.5, yearsSinceActive / halfLife);
+    }
+
+    const decay = 1 + (recency - 1) * 0.2; // Recency contributes 0-20%
+    strength *= decay;
+
+    // Mutual friends bonus
+    const mutuals = new Set();
+    const neighborsA = adjacency.get(nameA);
+    const neighborsB = adjacency.get(nameB);
+
+    for (const neighbor of neighborsA) {
+      if (neighbor !== nameB && neighborsB.has(neighbor)) {
+        mutuals.add(neighbor);
+      }
+    }
+
+    strength += mutuals.size * 0.1;
+
+    strengthMap.set(pairKey, {
+      strength,
+      decay,
+      recency,
+      mutualCount: mutuals.size
+    });
+  }
+
+  return strengthMap;
+}
+
+/**
+ * Computes comprehensive network health metrics
+ * Measures overall network connectivity, evolution, and activity
+ *
+ * @param {Array<{name: string}>} nodes
+ * @param {Array} links
+ * @param {Array} arcData - People with first_year, last_year, category
+ * @param {number} currentYear - Current year (default 2026)
+ * @returns {{
+ *   avgDegree: number,
+ *   density: number,
+ *   avgClusteringCoeff: number,
+ *   giantComponentSize: number,
+ *   avgPathLength: number,
+ *   networkCentralization: number,
+ *   activeRatio: number,
+ *   churnRate: number
+ * }}
+ */
+export function computeNetworkHealth(nodes, links, arcData = [], currentYear = 2026) {
+  const nodeNames = nodes.map(n => getName(n));
+  const n = nodeNames.length;
+
+  if (n === 0) {
+    return {
+      avgDegree: 0,
+      density: 0,
+      avgClusteringCoeff: 0,
+      giantComponentSize: 0,
+      avgPathLength: 0,
+      networkCentralization: 0,
+      activeRatio: 0,
+      churnRate: 0
+    };
+  }
+
+  const adjacency = buildAdjacencyList(nodes, links);
+
+  // 1. Average degree
+  let totalDegree = 0;
+  for (const neighbors of adjacency.values()) {
+    totalDegree += neighbors.size;
+  }
+  const avgDegree = totalDegree / n;
+
+  // 2. Density
+  const maxEdges = (n * (n - 1)) / 2;
+  const actualEdges = totalDegree / 2;
+  const density = n > 1 ? actualEdges / maxEdges : 0;
+
+  // 3. Average clustering coefficient
+  const clustering = computeClusteringCoeff(nodes, links);
+  let sumClustering = 0;
+  for (const coeff of clustering.values()) {
+    sumClustering += coeff;
+  }
+  const avgClusteringCoeff = sumClustering / n;
+
+  // 4. Giant component size (using BFS)
+  const giantComponentSize = findGiantComponent(adjacency, nodeNames);
+
+  // 5. Average shortest path (sample-based for performance)
+  const avgPathLength = estimateAvgShortestPath(adjacency, nodeNames);
+
+  // 6. Network centralization (how star-like)
+  const degrees = Array.from(adjacency.values()).map(neighbors => neighbors.size);
+  const maxDegree = Math.max(...degrees, 0);
+  let centralizationSum = 0;
+  for (const degree of degrees) {
+    centralizationSum += maxDegree - degree;
+  }
+  const networkCentralization = n > 1 ? centralizationSum / ((n - 1) * (n - 2)) : 0;
+
+  // 7. Active ratio (nodes active in last 3 years)
+  const personMap = new Map();
+  for (const person of arcData) {
+    const pName = person.name || person.person;
+    if (pName) personMap.set(pName, person);
+  }
+
+  let activeCount = 0;
+  for (const name of nodeNames) {
+    const person = personMap.get(name);
+    if (person && person.last_year && person.last_year >= currentYear - 3) {
+      activeCount++;
+    }
+  }
+  const activeRatio = n > 0 ? activeCount / n : 0;
+
+  // 8. Churn rate (faded out: last_year < currentYear - 5)
+  let churnCount = 0;
+  for (const name of nodeNames) {
+    const person = personMap.get(name);
+    if (person && person.last_year && person.last_year < currentYear - 5) {
+      churnCount++;
+    }
+  }
+  const churnRate = n > 0 ? churnCount / n : 0;
+
+  return {
+    avgDegree,
+    density,
+    avgClusteringCoeff,
+    giantComponentSize,
+    avgPathLength,
+    networkCentralization,
+    activeRatio,
+    churnRate
+  };
+}
+
+/**
+ * Finds the size of the largest connected component
+ * @private
+ */
+function findGiantComponent(adjacency, nodeNames) {
+  const visited = new Set();
+  let maxSize = 0;
+
+  for (const startNode of nodeNames) {
+    if (visited.has(startNode)) continue;
+
+    const component = new Set();
+    const queue = [startNode];
+    visited.add(startNode);
+    component.add(startNode);
+
+    while (queue.length > 0) {
+      const node = queue.shift();
+      for (const neighbor of adjacency.get(node)) {
+        if (!visited.has(neighbor)) {
+          visited.add(neighbor);
+          component.add(neighbor);
+          queue.push(neighbor);
+        }
+      }
+    }
+
+    maxSize = Math.max(maxSize, component.size);
+  }
+
+  return maxSize;
+}
+
+/**
+ * Estimates average shortest path using sampling
+ * @private
+ */
+function estimateAvgShortestPath(adjacency, nodeNames) {
+  const n = nodeNames.length;
+  if (n < 2) return 0;
+
+  // Sample up to 50 nodes for performance
+  const sampleSize = Math.min(50, n);
+  const samples = [];
+  for (let i = 0; i < sampleSize; i++) {
+    samples.push(nodeNames[Math.floor(Math.random() * n)]);
+  }
+
+  let totalPathLength = 0;
+  let pairCount = 0;
+
+  for (const source of samples) {
+    const distance = new Map();
+    for (const node of nodeNames) {
+      distance.set(node, Infinity);
+    }
+    distance.set(source, 0);
+
+    const queue = [source];
+    while (queue.length > 0) {
+      const u = queue.shift();
+      for (const v of adjacency.get(u)) {
+        if (distance.get(v) === Infinity) {
+          distance.set(v, distance.get(u) + 1);
+          queue.push(v);
+        }
+      }
+    }
+
+    for (const [target, dist] of distance) {
+      if (target !== source && dist !== Infinity) {
+        totalPathLength += dist;
+        pairCount++;
+      }
+    }
+  }
+
+  return pairCount > 0 ? totalPathLength / pairCount : 0;
+}
+
+/**
+ * Computes composite person scores based on multiple centrality measures
+ * Higher score = more important/influential person
+ *
+ * @param {Array<{name: string}>} nodes
+ * @param {Array} links
+ * @param {Map<string, number>} pageRank - From computePageRank
+ * @param {Map<string, number>} betweenness - From computeBetweenness
+ * @param {Map<string, number>} clustering - From computeClusteringCoeff
+ * @param {Array} arcData - People with mention counts and active years
+ * @returns {Map<string, {
+ *   socialGravity: number,
+ *   pageRank: number,
+ *   betweenness: number,
+ *   clustering: number,
+ *   mentions: number,
+ *   span: number,
+ *   percentile: number
+ * }>}
+ */
+export function computePersonScores(nodes, links, pageRank, betweenness, clustering, arcData = []) {
+  const nodeNames = nodes.map(n => getName(n));
+
+  // Build person data map (supports both .name and .person keys)
+  const personData = new Map();
+  for (const person of arcData) {
+    const pName = person.name || person.person;
+    if (pName) personData.set(pName, person);
+  }
+
+  // Compute mention counts and spans
+  const mentionCounts = new Map();
+  const activeSpans = new Map();
+
+  for (const name of nodeNames) {
+    const person = personData.get(name);
+    if (person) {
+      const mentions = person.total_mentions || person.mention_count || 0;
+      const span = (person.last_year || 2026) - (person.first_year || 2004) + 1;
+      mentionCounts.set(name, mentions);
+      activeSpans.set(name, span);
+    } else {
+      mentionCounts.set(name, 0);
+      activeSpans.set(name, 1);
+    }
+  }
+
+  // Normalize all scores
+  const normPageRank = normalizeScores(pageRank);
+  const normBetweenness = normalizeScores(betweenness);
+  const normClustering = normalizeScores(clustering);
+  const normMentions = normalizeScores(mentionCounts);
+  const normSpan = normalizeScores(activeSpans);
+
+  // Compute composite scores
+  const scores = new Map();
+  const gravityScores = [];
+
+  for (const name of nodeNames) {
+    const pr = normPageRank.get(name) || 0;
+    const bet = normBetweenness.get(name) || 0;
+    const clust = normClustering.get(name) || 0;
+    const ment = normMentions.get(name) || 0;
+    const span = normSpan.get(name) || 0;
+
+    const socialGravity = 0.3 * pr + 0.25 * bet + 0.15 * clust + 0.15 * ment + 0.15 * span;
+
+    scores.set(name, {
+      socialGravity,
+      pageRank: pr,
+      betweenness: bet,
+      clustering: clust,
+      mentions: ment,
+      span: span,
+      percentile: 0 // Computed after sorting
+    });
+
+    gravityScores.push({ name, score: socialGravity });
+  }
+
+  // Compute percentiles
+  gravityScores.sort((a, b) => a.score - b.score);
+  for (let i = 0; i < gravityScores.length; i++) {
+    const percentile = (i / Math.max(gravityScores.length - 1, 1)) * 100;
+    const score = scores.get(gravityScores[i].name);
+    score.percentile = Math.round(percentile);
+  }
+
+  return scores;
+}
+
+/**
+ * Computes temporal evolution of the network year by year
+ * Tracks growth, churn, and composition changes
+ *
+ * @param {Array<{name: string}>} nodes
+ * @param {Array} arcData - People with first_year, last_year, category
+ * @param {number} currentYear - Current year (default 2026)
+ * @returns {Array<{
+ *   year: number,
+ *   activeCount: number,
+ *   newCount: number,
+ *   lostCount: number,
+ *   networkAge: number,
+ *   diversityIndex: number
+ * }>}
+ */
+export function computeTemporalEvolution(nodes, arcData = [], currentYear = 2026) {
+  const nodeNames = new Set(nodes.map(n => getName(n)));
+
+  // Build person data map (supports both .name and .person keys)
+  const personData = new Map();
+  for (const person of arcData) {
+    const pName = person.name || person.person;
+    if (pName && nodeNames.has(pName)) {
+      personData.set(pName, { ...person, name: pName });
+    }
+  }
+
+  const startYear = 2004;
+  const evolution = [];
+
+  for (let year = startYear; year <= currentYear; year++) {
+    const activePeople = [];
+    let newCount = 0;
+    let lostCount = 0;
+
+    for (const [name, person] of personData) {
+      const firstYear = person.first_year || startYear;
+      const lastYear = person.last_year || currentYear;
+
+      // Active in this year
+      if (firstYear <= year && year <= lastYear) {
+        activePeople.push(person);
+
+        // New this year
+        if (firstYear === year) {
+          newCount++;
+        }
+      }
+
+      // Lost this year (was active last year, not this year)
+      if (year > startYear) {
+        const prevFirstYear = person.first_year || startYear;
+        const prevLastYear = person.last_year || currentYear;
+
+        if (prevFirstYear <= year - 1 && year - 1 <= prevLastYear &&
+            !(firstYear <= year && year <= lastYear)) {
+          lostCount++;
+        }
+      }
+    }
+
+    // Network age: average years known of active people
+    let networkAge = 0;
+    if (activePeople.length > 0) {
+      for (const person of activePeople) {
+        const yearsKnown = year - (person.first_year || startYear) + 1;
+        networkAge += yearsKnown;
+      }
+      networkAge /= activePeople.length;
+    }
+
+    // Diversity index: Shannon entropy of category distribution
+    let diversityIndex = 0;
+    if (activePeople.length > 0) {
+      const categoryCount = new Map();
+      for (const person of activePeople) {
+        const cat = person.category || 'unknown';
+        categoryCount.set(cat, (categoryCount.get(cat) || 0) + 1);
+      }
+
+      let entropy = 0;
+      for (const count of categoryCount.values()) {
+        const p = count / activePeople.length;
+        entropy -= p * Math.log2(p);
+      }
+      diversityIndex = entropy; // Normalized 0 to log2(categories)
+    }
+
+    evolution.push({
+      year,
+      activeCount: activePeople.length,
+      newCount,
+      lostCount,
+      networkAge,
+      diversityIndex
+    });
+  }
+
+  return evolution;
+}
+
+/**
+ * Analyzes relationship between two specific people
+ * Comprehensive pairwise analysis
+ *
+ * @param {string} nameA
+ * @param {string} nameB
+ * @param {Array} links
+ * @param {Map} coOccurrences - Map of "nameA|nameB" â†’ count
+ * @param {Array} arcData - People with temporal data
+ * @param {Map<string, number>} pageRank - From computePageRank
+ * @returns {{
+ *   sharedYearsCount: number,
+ *   coOccurrenceCount: number,
+ *   mutualFriends: string[],
+ *   strengthScore: number,
+ *   combinedPageRank: number,
+ *   relationship: 'strong'|'moderate'|'weak'|'dormant'
+ * }}
+ */
+export function analyzePair(nameA, nameB, links = [], coOccurrences = new Map(), arcData = [], pageRank = new Map()) {
+  let sharedYearsCount = 0;
+  let personAData = null;
+  let personBData = null;
+
+  for (const person of arcData) {
+    const pName = person.name || person.person;
+    if (pName === nameA) personAData = person;
+    if (pName === nameB) personBData = person;
+  }
+
+  // Compute shared active years
+  if (personAData && personBData) {
+    const startA = personAData.first_year || 2004;
+    const endA = personAData.last_year || 2026;
+    const startB = personBData.first_year || 2004;
+    const endB = personBData.last_year || 2026;
+
+    const overlapStart = Math.max(startA, startB);
+    const overlapEnd = Math.min(endA, endB);
+
+    if (overlapStart <= overlapEnd) {
+      sharedYearsCount = overlapEnd - overlapStart + 1;
+    }
+  }
+
+  // Co-occurrence count
+  const [name1, name2] = nameA < nameB ? [nameA, nameB] : [nameB, nameA];
+  const pairKey = `${name1}|${name2}`;
+  const coOccurrenceCount = coOccurrences.get(pairKey) || 0;
+
+  // Mutual friends
+  const mutualFriends = [];
+  const links1 = new Set();
+  const links2 = new Set();
+
+  for (const link of links) {
+    const source = typeof link.source === 'string' ? link.source : link.source.name;
+    const target = typeof link.target === 'string' ? link.target : link.target.name;
+
+    if (source === nameA) links1.add(target);
+    else if (target === nameA) links1.add(source);
+
+    if (source === nameB) links2.add(target);
+    else if (target === nameB) links2.add(source);
+  }
+
+  for (const friend of links1) {
+    if (links2.has(friend) && friend !== nameA && friend !== nameB) {
+      mutualFriends.push(friend);
+    }
+  }
+
+  // Strength score (check if link exists)
+  let strengthScore = 0;
+  for (const link of links) {
+    const source = typeof link.source === 'string' ? link.source : link.source.name;
+    const target = typeof link.target === 'string' ? link.target : link.target.name;
+
+    if ((source === nameA && target === nameB) || (source === nameB && target === nameA)) {
+      strengthScore = link.weight || 1;
+      break;
+    }
+  }
+
+  // Add co-occurrence and mutual bonus
+  strengthScore += coOccurrenceCount * 0.3 + mutualFriends.length * 0.1;
+
+  // Combined PageRank
+  const prA = pageRank.get(nameA) || 0;
+  const prB = pageRank.get(nameB) || 0;
+  const combinedPageRank = prA + prB;
+
+  // Determine relationship type
+  let relationship = 'dormant';
+  if (strengthScore > 2) relationship = 'strong';
+  else if (strengthScore > 1) relationship = 'moderate';
+  else if (strengthScore > 0) relationship = 'weak';
+
+  return {
+    sharedYearsCount,
+    coOccurrenceCount,
+    mutualFriends,
+    strengthScore,
+    combinedPageRank,
+    relationship
+  };
+}
-- 
2.34.1


From 6c60f276e15eafab693c2b67fddb404bc894e6e8 Mon Sep 17 00:00:00 2001
From: Mike <njrun1804@gmail.com>
Date: Mon, 9 Feb 2026 03:52:43 +0000
Subject: [PATCH 2/2] =?UTF-8?q?Constellation:=20add=20entity=20resolution?=
 =?UTF-8?q?=20=E2=80=94=20merge=20duplicate=20names=20across=20all=20data?=
 =?UTF-8?q?=20sources?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

New name-resolver.js module with hand-curated alias map covering 50+ name
variants, plus automatic parenthetical stripping, possessive cleanup, and
ECD scraping artifact removal.

Key merges:
- Dan Spengeman / Danny Sponge / Spengeman â†’ Dan Spengeman
- Rob / RK (Rob Knott) / Rob Phillips (Robert) â†’ Rob
- Kevin Megill / Kevin Megill (KMJ) / Megill â†’ Kevin Megill
- Michael Krott / Mike Krott / Mike 'Sputz' Krott â†’ Michael Krott
- Ryan Letsche / RL (Letsche) / RyGuy â†’ Ryan Letsche
- Julia Dennabuam â†’ Julia Dennebaum (spelling fix)
- Bethany Schon â†’ Bethany Schonberg
- Joey Kelly â†’ Joe Kelly
- 30+ additional nickname/initial/parenthetical merges

Integration:
- All data sources (constellation nodes/links, co-occurrences, person_arc,
  people, profiles, ECD players, ECD network) pass through name resolution
  before any analytics or rendering
- Duplicate nodes merged (higher importance score wins)
- Self-loop links removed (e.g. "Dan Spengeman" â†” "Danny Sponge")
- Duplicate edges merged by summing weights
- focusNodeByName() resolves aliases for sidebar navigation
- Sidebar shows "aka" line for merged people

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>
---
 timeline-of-tron/js/constellation.js |  83 ++++-
 timeline-of-tron/js/name-resolver.js | 438 +++++++++++++++++++++++++++
 2 files changed, 512 insertions(+), 9 deletions(-)
 create mode 100644 timeline-of-tron/js/name-resolver.js

diff --git a/timeline-of-tron/js/constellation.js b/timeline-of-tron/js/constellation.js
index 6a27ad9..c13696e 100644
--- a/timeline-of-tron/js/constellation.js
+++ b/timeline-of-tron/js/constellation.js
@@ -15,6 +15,15 @@ import {
     computePersonScores,
     computeTemporalEvolution
 } from './graph-analytics.js';
+import {
+    resolveName,
+    deduplicateNodes,
+    deduplicateLinks,
+    deduplicateCoOccurrences,
+    deduplicateArcs,
+    resolveProfileKey,
+    getAliases
+} from './name-resolver.js';
 
 const ERA_COLORS = {
     early: '#4a90d9',    // 2004-2008: blue
@@ -199,14 +208,58 @@ export async function initConstellation() {
         data.ecd_player_network = extras.ecd_player_network;
     } catch (_) { /* enrichment data unavailable â€” page still works */ }
 
-    const constellation = data.relationship_constellation;
-    profilesData = buildProfileMap(data.people_profiles);
-    peopleData = buildPeopleMap(data.people);
-    arcData = buildArcMap(data.person_arc);
-    coOccurrencesData = data.co_occurrences || [];
-    ecdPlayersData = buildEcdPlayerMap(data.ecd_players);
+    // â”€â”€â”€ Name Resolution: Deduplicate before anything touches the data â”€â”€â”€â”€
+    const rawConstellation = data.relationship_constellation || { nodes: [], links: [] };
+    const constellation = {
+        ...rawConstellation,
+        nodes: deduplicateNodes(rawConstellation.nodes || []),
+        links: deduplicateLinks(rawConstellation.links || [])
+    };
+    const deduplicatedNodeCount = (rawConstellation.nodes || []).length - constellation.nodes.length;
+    if (deduplicatedNodeCount > 0) {
+        console.log(`[NameResolver] Merged ${deduplicatedNodeCount} duplicate nodes in constellation`);
+    }
+    const deduplicatedLinkCount = (rawConstellation.links || []).length - constellation.links.length;
+    if (deduplicatedLinkCount > 0) {
+        console.log(`[NameResolver] Merged ${deduplicatedLinkCount} duplicate/self-loop links`);
+    }
+
+    // Resolve names in co-occurrences before building maps
+    const rawCoOcc = data.co_occurrences || [];
+    const resolvedCoOcc = deduplicateCoOccurrences(rawCoOcc);
+
+    // Resolve names in person_arc before building arc map
+    const rawArc = data.person_arc || [];
+    const resolvedArc = deduplicateArcs(rawArc);
+
+    // Resolve names in people data
+    const rawPeople = data.people || [];
+    rawPeople.forEach(p => { p.name = resolveName(p.name); });
+
+    // Resolve names in people_profiles
+    const rawProfiles = data.people_profiles || [];
+    rawProfiles.forEach(p => {
+        if (p.person) p.person.name = resolveName(p.person.name);
+    });
+
+    // Resolve names in ECD players
+    const rawEcd = data.ecd_players || [];
+    rawEcd.forEach(p => { p.name = resolveName(p.name); });
+
+    // Resolve names in ECD player network
+    const rawEcdNet = data.ecd_player_network || { nodes: [], links: [] };
+    const ecdNet = {
+        nodes: deduplicateNodes(rawEcdNet.nodes || []),
+        links: deduplicateLinks(rawEcdNet.links || [])
+    };
+
+    profilesData = buildProfileMap(rawProfiles);
+    peopleData = buildPeopleMap(rawPeople);
+    arcData = buildArcMap(resolvedArc);
+    coOccurrencesData = resolvedCoOcc;
+    ecdPlayersData = buildEcdPlayerMap(rawEcd);
     ecdAwardsData = data.ecd_awards_v2 || [];
-    ecdPlayerNetworkData = data.ecd_player_network || { nodes: [], links: [] };
+    ecdPlayerNetworkData = ecdNet;
     lifeChaptersData = data.life_chapters || [];
     songsByPerson = buildSongPersonMap(data.song_person_map);
 
@@ -214,7 +267,7 @@ export async function initConstellation() {
     // but not in people_profiles (covers more people)
     const personTimelines = data.person_timelines || [];
     personTimelines.forEach(evt => {
-        const name = evt.person_name;
+        const name = resolveName(evt.person_name);
         if (!name) return;
         if (!profilesData[name]) {
             profilesData[name] = {
@@ -764,7 +817,8 @@ function highlightMatch(text, query) {
 
 function focusNodeByName(name) {
     if (!svgNode || !svgLink) return;
-    const targetNode = allNodes.find(n => n.name === name);
+    const resolved = resolveName(name);
+    const targetNode = allNodes.find(n => n.name === resolved) || allNodes.find(n => n.name === name);
     if (!targetNode) return;
 
     const connected = new Set();
@@ -1474,6 +1528,17 @@ function showPersonPanel(d) {
 
     let html = `<button class="sidebar-close">&times;</button>`;
     html += `<h2 class="person-name">${d.name}</h2>`;
+    // Show aliases if this person was merged from other name variants
+    const aliases = getAliases(d.name);
+    if (aliases.length > 0) {
+        const displayAliases = aliases
+            .filter(a => a.length > 2 && !a.includes("it's") && !a.includes(' it') && !a.includes(' on') && !a.endsWith("'s"))
+            .slice(0, 4)
+            .map(a => a.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' '));
+        if (displayAliases.length > 0) {
+            html += `<p class="person-more-note">aka ${displayAliases.join(', ')}</p>`;
+        }
+    }
     if (relation) html += `<p class="person-relation-tag">${relation}</p>`;
     else if (category && category !== 'other') html += `<p class="person-relation-tag">${formatAwardCategory(category)}</p>`;
 
diff --git a/timeline-of-tron/js/name-resolver.js b/timeline-of-tron/js/name-resolver.js
new file mode 100644
index 0000000..21699f1
--- /dev/null
+++ b/timeline-of-tron/js/name-resolver.js
@@ -0,0 +1,438 @@
+/**
+ * Name Resolver â€” Entity resolution for the Constellation
+ *
+ * Problem: The same person can appear under multiple names across data sources:
+ *   "Dan Spengeman", "Danny Sponge", "Spengeman"
+ *   "Rob", "RK (Rob Knott)", "Rob Phillips (Robert)"
+ *   "Michael Krott", "Mike Krott", "Mike 'Sputz' Krott", "Sputz"
+ *
+ * This module provides a canonical-name mapping so the analytics engine
+ * treats all variants as the same node.
+ *
+ * Approach:
+ *   1. Hand-curated ALIAS_MAP for known duplicates (high confidence)
+ *   2. Automatic parenthetical stripping ("Juan Londono (Muffin Man)" â†’ "Juan Londono")
+ *   3. Possessive stripping ("Dan Spengeman's" â†’ "Dan Spengeman")
+ *   4. ECD nickname matching ("Spengeman" â†’ "Dan Spengeman")
+ *   5. Fuzzy last-name + first-initial matching for remaining edge cases
+ */
+
+// â”€â”€â”€ Hand-Curated Alias Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+// key = variant name (lowercased), value = canonical name (exact casing)
+// This is the ground truth. Add entries as new duplicates are discovered.
+
+const ALIAS_MAP = {
+    // Dan Spengeman cluster
+    'danny sponge':                   'Dan Spengeman',
+    'spengeman':                      'Dan Spengeman',
+    "dan spengeman's":                'Dan Spengeman',
+
+    // Rob / Partner cluster
+    'rk (rob knott)':                 'Rob',
+    'rob knott':                      'Rob',
+    'rob phillips (robert)':          'Rob',
+    'rob phillips':                   'Rob',
+    'rk':                             'Rob',
+
+    // Kevin Megill cluster
+    'kevin megill (kmj)':             'Kevin Megill',
+    'kmj':                            'Kevin Megill',
+    'legend kevin megill':            'Kevin Megill',
+    'megill':                         'Kevin Megill',
+
+    // Michael Krott cluster
+    'mike krott':                     'Michael Krott',
+    "mike 'sputz' krott":            'Michael Krott',
+    'michael sputz krott':            'Michael Krott',
+    'sputz':                          'Michael Krott',
+
+    // Ryan Letsche cluster
+    'ryan letsche (ryguy)':           'Ryan Letsche',
+    'ryguy (brody\'s big brother)':   'Ryan Letsche',
+    'rl (letsche)':                   'Ryan Letsche',
+    'letsche':                        'Ryan Letsche',
+
+    // Juan Londono cluster
+    'juan londono (muffin man)':      'Juan Londono',
+    'londono':                        'Juan Londono',
+
+    // Valerie Winston cluster
+    'valerie winston (valpal)':       'Valerie Winston',
+    'valerie winston (valpal':        'Valerie Winston',  // malformed in data
+    'valpal':                         'Valerie Winston',
+
+    // Kevin Adams cluster
+    'kevin adams (the axe)':          'Kevin Adams',
+    'the annihilator':                'Kevin Adams',
+
+    // Chris Arbach / Topher cluster
+    'chris arbach (topher)':          'Chris Arbach',
+    'topher':                         'Chris Arbach',
+
+    // Grant Cornero cluster
+    'grant cornero (grantman)':       'Grant Cornero',
+    'grantman':                       'Grant Cornero',
+
+    // Michelle Mullins cluster
+    'michelle mullins (muffins)':     'Michelle Mullins',
+    'muffins':                        'Michelle Mullins',
+
+    // Joe Kelly cluster
+    'joey kelly':                     'Joe Kelly',
+
+    // Julia Dennebaum spelling
+    'julia dennabuam':                'Julia Dennebaum',
+
+    // Bethany Schonberg spelling
+    'bethany schon':                  'Bethany Schonberg',
+
+    // Sara DeCuir casing
+    'sara decuir':                    'Sara DeCuir',
+
+    // Mike Edwards cluster
+    'michael edwards':                'Mike Edwards',
+    'edwards':                        'Mike Edwards',
+
+    // Michael Butler cluster
+    'michael butler':                 'Mike Butler',
+
+    // Dan Turner cluster
+    'dan turner word':                'Dan Turner',
+    'd turner':                       'Dan Turner',
+
+    // Tom Adams / Punter cluster
+    'the punter':                     'Tom Adams',
+    'punter wolf':                    'Tom Adams',
+
+    // Diana DiBuccio cluster
+    'di buccio':                      'Diana DiBuccio',
+    'dibuccio':                       'Diana DiBuccio',
+    'diana di':                       'Diana DiBuccio',
+
+    // Justin Pierce cluster
+    'pierce':                         'Justin Pierce',
+    'the piercer':                    'Justin Pierce',
+
+    // Michael Rosinski cluster
+    'mike rosinski':                  'Michael Rosinski',
+    'rosinski':                       'Michael Rosinski',
+
+    // Kevin Fitzpatrick cluster
+    'fitz':                           'Kevin Fitzpatrick',
+
+    // Kathryn Nogueira cluster
+    'kathryn kitty nogueira':         'Kathryn Nogueira',
+    'liz nogueira':                   'Elizabeth Nogueira',
+
+    // Justin Wolf cluster
+    "justin wolf's":                  'Justin Wolf',
+    'wolf':                           'Justin Wolf',
+
+    // Joey Smalls cluster
+    "joey smalls's":                  'Joey Smalls',
+
+    // James Butler / Boofer
+    'james butler (boofer)':          'James Butler',
+    'boofer':                         'James Butler',
+
+    // Joe Corcione
+    'joe corcione (giuseppe nj)':     'Joe Corcione',
+
+    // Bojana Beric
+    'bojana beric (prof. beric)':     'Bojana Beric',
+
+    // Sascha Basista
+    'basista':                        'Sascha Basista',
+
+    // Lauren Freda
+    // NOTE: bare "Lauren" is ambiguous (could be Lauren Winston, Lauren Stopa, Lauren Freda)
+    // Only map it if it appears in an ECD-only context
+
+    // Joanice Lima
+    'lima':                           'Joanice Lima',
+
+    // Couple entries â€” map to the primary person
+    'kevin & leah (kmj & ln)':        'Kevin Megill',
+
+    // Possessive forms that leak from ECD scraping
+    "steve adams it's":               'Steve Adams',
+    'steve adams it':                 'Steve Adams',
+    "kevin adams it's":               'Kevin Adams',
+    "matt brown it's":                'Matt Brown',
+    "sister it's":                    'Sister',
+    'john tronolone it':              'John Tronolone',
+    'winston it':                     'Valerie Winston',
+    'cornero on':                     'Grant Cornero',
+    'ray marzarella on':              'Ray Marzarella',
+
+    // T. Adams (Greek) â€” likely Tom Adams or a distinct person
+    't. adams (greek)':               'Tom Adams',
+
+    // P-A-M-U-L-A
+    'p-a-m-u-l-a (pamula)':          'Pamula',
+};
+
+// â”€â”€â”€ Build fast lookup (case-insensitive) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+const _aliasLookup = new Map();
+for (const [variant, canonical] of Object.entries(ALIAS_MAP)) {
+    _aliasLookup.set(variant.toLowerCase().trim(), canonical);
+}
+
+/**
+ * Resolves a name to its canonical form.
+ *
+ * Pipeline:
+ *   1. Exact alias match (case-insensitive)
+ *   2. Strip possessive 's
+ *   3. Strip trailing garbage ("It", "It's", "On", etc.)
+ *   4. Check alias again after cleaning
+ *   5. Strip parenthetical nicknames, re-check
+ *   6. Return cleaned name if no alias found
+ *
+ * @param {string} rawName
+ * @returns {string} canonical name
+ */
+export function resolveName(rawName) {
+    if (!rawName || typeof rawName !== 'string') return rawName;
+
+    let name = rawName.trim();
+
+    // 1. Direct alias match
+    const directMatch = _aliasLookup.get(name.toLowerCase());
+    if (directMatch) return directMatch;
+
+    // 2. Strip possessive 's
+    if (name.endsWith("'s") || name.endsWith("'s")) {
+        name = name.slice(0, -2).trim();
+        const match = _aliasLookup.get(name.toLowerCase());
+        if (match) return match;
+    }
+
+    // 3. Strip trailing garbage tokens from ECD scraping
+    const garbageTokens = [' it', " it's", ' on', ' the', ' a'];
+    for (const token of garbageTokens) {
+        if (name.toLowerCase().endsWith(token)) {
+            const cleaned = name.slice(0, -token.length).trim();
+            const match = _aliasLookup.get(cleaned.toLowerCase());
+            if (match) return match;
+            name = cleaned;
+        }
+    }
+
+    // 4. Re-check after cleaning
+    const cleanedMatch = _aliasLookup.get(name.toLowerCase());
+    if (cleanedMatch) return cleanedMatch;
+
+    // 5. Strip parenthetical nicknames: "Juan Londono (Muffin Man)" â†’ "Juan Londono"
+    const parenMatch = name.match(/^(.+?)\s*\(.*$/);
+    if (parenMatch) {
+        const baseName = parenMatch[1].trim();
+        const baseMatch = _aliasLookup.get(baseName.toLowerCase());
+        if (baseMatch) return baseMatch;
+
+        // Also check the full parenthetical form
+        const fullMatch = _aliasLookup.get(name.toLowerCase());
+        if (fullMatch) return fullMatch;
+
+        // Return the base name (without parenthetical) if no alias
+        return baseName;
+    }
+
+    return name;
+}
+
+/**
+ * Checks if two names refer to the same person.
+ *
+ * @param {string} nameA
+ * @param {string} nameB
+ * @returns {boolean}
+ */
+export function isSamePerson(nameA, nameB) {
+    if (!nameA || !nameB) return false;
+    return resolveName(nameA) === resolveName(nameB);
+}
+
+/**
+ * Normalizes an array of node objects, merging duplicate names.
+ * For merged nodes, combines importance scores and takes the richer metadata.
+ *
+ * @param {Array<{name: string, ...}>} nodes
+ * @returns {Array<{name: string, ...}>} deduplicated nodes
+ */
+export function deduplicateNodes(nodes) {
+    const canonical = new Map(); // canonical name â†’ merged node
+
+    for (const node of nodes) {
+        const resolved = resolveName(node.name);
+
+        if (canonical.has(resolved)) {
+            const existing = canonical.get(resolved);
+
+            // Merge: keep the higher importance score
+            if ((node.importance_score || 0) > (existing.importance_score || 0)) {
+                canonical.set(resolved, {
+                    ...node,
+                    name: resolved,
+                    importance_score: Math.max(
+                        node.importance_score || 0,
+                        existing.importance_score || 0
+                    ),
+                    _mergedFrom: [...(existing._mergedFrom || [existing.name]), node.name]
+                });
+            } else {
+                existing.importance_score = Math.max(
+                    node.importance_score || 0,
+                    existing.importance_score || 0
+                );
+                existing._mergedFrom = [...(existing._mergedFrom || [existing.name]), node.name];
+            }
+        } else {
+            canonical.set(resolved, { ...node, name: resolved });
+        }
+    }
+
+    return Array.from(canonical.values());
+}
+
+/**
+ * Normalizes an array of link objects, resolving both source and target names.
+ * Removes self-loops that arise from merging (e.g., "Dan Spengeman" â†” "Danny Sponge").
+ * Merges duplicate edges by summing weights.
+ *
+ * @param {Array<{source: string, target: string, weight?: number, ...}>} links
+ * @returns {Array<{source: string, target: string, weight: number, ...}>}
+ */
+export function deduplicateLinks(links) {
+    const edgeMap = new Map(); // "nameA|nameB" â†’ merged link
+
+    for (const link of links) {
+        const source = resolveName(
+            typeof link.source === 'string' ? link.source : link.source?.name || ''
+        );
+        const target = resolveName(
+            typeof link.target === 'string' ? link.target : link.target?.name || ''
+        );
+
+        // Skip self-loops (same person after resolution)
+        if (source === target) continue;
+        if (!source || !target) continue;
+
+        // Normalize edge key (alphabetical order)
+        const [a, b] = source < target ? [source, target] : [target, source];
+        const key = `${a}|${b}`;
+
+        if (edgeMap.has(key)) {
+            const existing = edgeMap.get(key);
+            existing.weight = (existing.weight || 1) + (link.weight || 1);
+        } else {
+            edgeMap.set(key, {
+                ...link,
+                source: a,
+                target: b,
+                weight: link.weight || 1
+            });
+        }
+    }
+
+    return Array.from(edgeMap.values());
+}
+
+/**
+ * Resolves names in co-occurrence records.
+ * Merges co-occurrences for the same canonical pair.
+ *
+ * @param {Array<{person_a: string, person_b: string, ...}>} coOccurrences
+ * @returns {Array} deduplicated co-occurrences
+ */
+export function deduplicateCoOccurrences(coOccurrences) {
+    const merged = new Map();
+
+    for (const co of coOccurrences) {
+        const a = resolveName(co.person_a);
+        const b = resolveName(co.person_b);
+
+        // Skip self-references
+        if (a === b) continue;
+
+        const [nameA, nameB] = a < b ? [a, b] : [b, a];
+        const key = `${nameA}|${nameB}|${co.year || ''}`;
+
+        if (merged.has(key)) {
+            const existing = merged.get(key);
+            existing.co_occurrence_count = (existing.co_occurrence_count || 1) +
+                                           (co.co_occurrence_count || 1);
+            // Keep richer context
+            if (co.context && co.context.length > (existing.context || '').length) {
+                existing.context = co.context;
+            }
+        } else {
+            merged.set(key, {
+                ...co,
+                person_a: nameA,
+                person_b: nameB
+            });
+        }
+    }
+
+    return Array.from(merged.values());
+}
+
+/**
+ * Resolves names in arc data (person_arc records).
+ * Merges arcs for the same person: widens year range, sums mentions.
+ *
+ * @param {Array<{person: string, first_year: number, last_year: number, total_mentions: number, ...}>} arcData
+ * @returns {Array} deduplicated arcs
+ */
+export function deduplicateArcs(arcData) {
+    const merged = new Map();
+
+    for (const arc of arcData) {
+        const name = resolveName(arc.person || arc.name);
+
+        if (merged.has(name)) {
+            const existing = merged.get(name);
+            existing.first_year = Math.min(existing.first_year || 9999, arc.first_year || 9999);
+            existing.last_year = Math.max(existing.last_year || 0, arc.last_year || 0);
+            existing.total_mentions = (existing.total_mentions || 0) + (arc.total_mentions || 0);
+            existing.peak_mentions = Math.max(existing.peak_mentions || 0, arc.peak_mentions || 0);
+            if ((arc.peak_mentions || 0) >= existing.peak_mentions) {
+                existing.peak_year = arc.peak_year;
+            }
+            existing.span = existing.last_year - existing.first_year;
+        } else {
+            merged.set(name, { ...arc, person: name, name: name });
+        }
+    }
+
+    return Array.from(merged.values());
+}
+
+/**
+ * Resolves a name in profile/people data lookups.
+ * Returns the canonical name so sidebar lookups work after deduplication.
+ *
+ * @param {string} name
+ * @returns {string}
+ */
+export function resolveProfileKey(name) {
+    return resolveName(name);
+}
+
+/**
+ * Returns all known aliases for a canonical name.
+ * Useful for sidebar display ("Also known as: ...").
+ *
+ * @param {string} canonicalName
+ * @returns {string[]} array of alias names (excluding the canonical)
+ */
+export function getAliases(canonicalName) {
+    const aliases = [];
+    for (const [variant, canonical] of _aliasLookup) {
+        if (canonical === canonicalName && variant !== canonicalName.toLowerCase()) {
+            aliases.push(variant);
+        }
+    }
+    return aliases;
+}
-- 
2.34.1

